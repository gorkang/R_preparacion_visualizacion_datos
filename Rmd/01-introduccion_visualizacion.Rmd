---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Introducción a R y visualización de datos

---  

#### Paquetes para este capítulo {-}

Para poder ejecutar en tu ordenador el código de los ejemplos y ejercicios de este capítulo vas a necesitar los paquetes siguientes. Te recomiendo que abras un script de R, pegues estas líneas al principio y las ejecutes (CNTRL + ENTER para ejecutar linea a linea).    

```{r setup, echo=TRUE}

if (!require('cowplot')) install.packages('cowplot'); library('cowplot')
if (!require('dplyr')) install.packages('dplyr'); library('dplyr')
if (!require('esquisse')) install.packages('esquisse'); library('esquisse') 
if (!require('gapminder')) install.packages('gapminder'); library('gapminder')
if (!require('gghighlight')) install.packages('gghighlight'); library('gghighlight')
if (!require('ggplot2')) install.packages('ggplot2'); library('ggplot2')
if (!require('ggthemes')) install.packages('ggthemes'); library('ggthemes')
if (!require('ggridges')) install.packages('ggridges'); library('ggridges')
if (!require('knitr')) install.packages('knitr'); library('knitr')
if (!require('plotly')) install.packages('plotly'); library('plotly')
if (!require('purrr')) install.packages('purrr'); library('purrr')
if (!require('readr')) install.packages('readr'); library('readr')
if (!require('sjPlot')) install.packages('sjPlot'); library('sjPlot')
if (!require('tidyr')) install.packages('tidyr'); library('tidyr')

```  

---  

## Introducción: porque la visualización de datos es importante


*"These 13 datasets (the Datasaurus, plus 12 others) each have the same summary statistics (x/y mean, x/y standard deviation, and Pearson's correlation) to two decimal places, while being drastically different in appearance."* (Matejka, J., & Fitzmaurice, G., 2017)  


![SOURCE: https://www.autodeskresearch.com/publications/samestats](`r here::here("data", "images", "DinoSequentialSmaller.gif")`)



### Ejemplo del mundo real: ¿cuantos temas deberia estudiar?

Este ejemplo viene de un experimento que realizamos junto con [Carlos Santamaría](https://scholar.google.es/citations?user=fUHQA3gAAAAJ&hl=es) hace algún tiempo. Presentamos una tarea sobre cálculo de probabilidades a personas que estaban entrando a un examen para convertirse en trabajadores del estado. Simplificando algo, digamos que la materia para el examen eran 80 temas. No es posible estudiar con profundidad todos los temas, así que los opositores se concentraban en un subconjunto de esos temas (e.g. 30 de 80). Al empezar el examen, se seleccionaban al azar 5 de los 80 temas, y cada persona elegía uno de ellos para desarrollar.  

Abajo se puede ver como cambia la probabilidad de que uno de los temas estudiados aparezca dentro de los 5 seleccionados al azar. Con 30 de los 80 temas estudiados, la probabilidad de que uno de ellos salga en la prueba es del 91%. Si estudiáramos 47, subiríamos a una probabilidad del 99%.    

```{r opositores-plot, echo=FALSE, fig.height=6, fig.width=8}

hipergeometric_formula <- function(temas_totales = 80,
                 temas_estudiados = 30,
                 temas_seleccionados = 5,
                 temas_estudiados_salen = 1:5) {

  temas_NO_estudiados = temas_totales - temas_estudiados # Temas NO estudiados

  if (temas_estudiados > temas_totales) {
    NA
  } else {
    sum(
      ((factorial(temas_estudiados) / (factorial(temas_estudiados_salen) * (factorial(temas_estudiados - temas_estudiados_salen)))) *
         (factorial(temas_NO_estudiados) / ((factorial(temas_seleccionados - temas_estudiados_salen)) * (factorial(temas_NO_estudiados - (temas_seleccionados - temas_estudiados_salen))))))
      /
      (factorial(temas_estudiados + temas_NO_estudiados) / (factorial(temas_seleccionados) * factorial(temas_estudiados + temas_NO_estudiados - temas_seleccionados))),
      na.rm = TRUE)
  }

}

temas_totales = 80
data_plot = 1:temas_totales %>% purrr::map_dfr(~ hipergeometric_formula(temas_totales = temas_totales, temas_estudiados = .x) %>% as_tibble() %>% mutate(N = .x))


plotly::ggplotly(
  ggplot(data_plot, aes(N, value)) +
    geom_line() +
    geom_vline(xintercept = 30, linetype = "dashed") +
    geom_hline(yintercept = 1, linetype = "dashed") +
    scale_x_continuous(n.breaks = 10) +
    scale_y_continuous(breaks = seq(0, 1, .05), labels = scales::percent(x = seq(0, 1, .05), accuracy = 1)) +
    labs(title = "Probabilidad de que uno de los temas estudiados aparezca",
         x = "Temas estudiados",
         y = "Probabilidad"))

  
```

<BR>
En el experimento le preguntamos a las personas por la probabilidad de que les apareciera alguno de los temas estudiados en la prueba. Comparamos las siguientes dos preguntas:  

+ ¿Cuál es la probabilidad de que **salga uno** de los temas que has estudiado?  
+ ¿Cuál es la probabilidad de que **no salga ninguno** de los temas que has estudiado?  

Miramos el error promedio en función de la pregunta (cuanto se han alejado de la probabilidad correcta), y vimos que nuestra manipulación había tenido un efecto considerable:  

```{r visualizacion-importante-01, echo=FALSE, cache=FALSE}

# Leemos datos
DF = read_csv(
  here::here("data", "files", "01-visualizacion-importante.csv")) %>% 
  mutate(Question = as.factor(
    case_when(Question_p_of == 1 ~ "p (salga uno)",
              Question_p_of == 0 ~ "p (no salga ninguno)")))

# Promedio por condición
DF %>% 
  group_by(Question) %>% 
  summarise(Error_promedio = mean(Error),
            SD = sd(Error, na.rm = TRUE),
            N = n()) %>% 
  knitr::kable()

```

<BR>

Hay una diferencia notable entre condiciones. Pasamos de un error promedio del -30.7% a tan solo 4%, simplemente cambiando la pregunta. Hagamos un sencillo análisis de regresión para ver si la diferencia es significativa, y cuanta varianza explica nuestro modelo.   


```{r visualizacion-importante-01b, echo=FALSE}
# Modelo de regresión
modelo_regresion = lm(Error ~ Question, DF)

# Resultados
sjPlot::tab_model(modelo_regresion)
# summary(modelo_regresion)
```


```{r visualizacion-importante-01c, echo=FALSE}
# Histograma de los residuos
hist(modelo_regresion$residuals)

# Supuesto de normalidad de residuales
shapiro.test(modelo_regresion$residuals)
```

<BR>
<details><summary>Todo es hermoso. Tenemos un efecto claramente significativo de la pregunta (y con un R2-ajustado de .258, no está nada mal), y además, nuestro modelo no incumple el supuesto de normalidad de residuos (por los pelos!). Léeme ![](data/images/hint.png)</summary><span style="color: orange;">[Las pruebas de normalidad son muy sensibles al n de la muestra](https://stats.stackexchange.com/questions/2492/is-normality-testing-essentially-useless)</span></details>   
Preparamos un plot con promedios y barras con error standard para nuestro paper.

```{r visualizacion-importante-01d, echo=FALSE}

# Plot para publicación
plot_inicial = ggplot(DF, aes(Question, Error, fill = Question)) +
  stat_summary(
    fun = mean,
    geom = "point",
    size = 4,
    color = "darkgrey") +
  stat_summary(geom = "errorbar", fun.data = mean_se, position = "dodge", color = "black", width = .2) +
  scale_y_continuous(limits = c(-50, 50), breaks = seq(-50, 50, 10)) +
  theme_minimal(base_size = 12) +
  labs(x = "What is the probability of x?") +
  theme(legend.position = "none")

plot_inicial

```

Estamos listos para escribir el paper.  Preparemos la tabla con descriptivos...

```{r visualizacion-importante-03, echo=FALSE}

# Promedio y mediana por condición
DF %>% 
  group_by(Question) %>% 
  summarise(Error_promedio = mean(Error),
            # Error_mediana = median(Error),
            SD = sd(Error, na.rm = TRUE),
            N = n()) %>% 
  knitr::kable()

```

Es curioso que la desviación estandard sea mayor en el grupo con menos error promedio... Visualicemos las respuestas de todos los participantes, junto con la distribución de los datos.  

```{r visualizacion-importante-04, echo=FALSE}

plot_final = ggplot(DF, aes(Error, Question, fill = Question, color = Question)) + 
  ggridges::geom_density_ridges(stat = "binline", bins = 20, scale = 0.8, draw_baseline = FALSE, alpha = .6) +
  ggridges::geom_density_ridges(jittered_points = TRUE, position = "raincloud", alpha = 0.7, scale = 0.9) +
  theme_minimal() +
  theme(legend.position = "none") +
  # scale_x_continuous(limits = c(-50, 50), breaks = seq(-50, 50, 10)) +
  labs(y = "What is the probability of x?") +
  coord_flip()

plot_final

```

Como se puede apreciar en la gráfica, cuando usamos la pregunta `¿Cuál es la probabilidad de que no salga ninguno de los temas que has estudiado?` no estamos reduciendo el error, sino convirtiendo una distribución de respuestas unimodal en bimodal.  

---  

**TLDR**: La manera en la visualizamos la información determina las conclusiones a las que llegamos. En una sola gráfica:     

```{r visualizacion-importante-05, fig.width=12, echo=FALSE}


# Visualizamos el gráfico inicial y el final, uno al lado del otro
cowplot::plot_grid(plot_inicial, plot_final, labels = c("Antes", "Después"))

```

#### Moraleja: es importante mostrar los datos individuales y/o la distribución de los datos {-}

![SOURCE: https://www.autodeskresearch.com/publications/samestats](`r here::here("data", "images", "BoxViolinSmaller.gif")`)



---  

## Por qué R? 

<div style= "float:left;position: relative; margin:0px 30px 0px 0px;">![](data/images/R_logo.png)</div>

R es [uno de los programas para data science mas populares](http://r4stats.com/articles/popularity/), especialmente usado en la academia. El numero de paquetes que ofrecen funcionalidades de todo tipo no ha dejado de crecer. En 2021 el numero de paquetes en [R-cran](https://cran.r-project.org/web/packages/index.html) ha superado los 19,000 ([ver este buscador de paquetes](https://mran.microsoft.com/packages)), y el ritmo de crecimiento nos acerca a la singularidad... ;)  

<BR>  

<div style="clear: both;"></div>

![SOURCE: https://gist.github.com/daroczig/3cf06d6db4be2bbe3368](`r here::here("data", "images", "number-of-submitted-packages-to-CRAN.png")`)

<!-- (https://gist.githubusercontent.com/daroczig/3cf06d6db4be2bbe3368/raw/b66b0531fb1b86d3e04a003b2e105ad4f147900e/number-of-submitted-packages-to-CRAN.png)   -->

<BR> 

Además de lo anterior, R es un programa de código abierto (algo esencial para poder hacer ciencia reproducible), con una [comunidad de usuarios](https://community.rstudio.com/) muy acogedora, y con un importante foco en la [inclusividad](https://qz.com/work/1661486/r-ladies-made-data-science-inclusive/). La importancia de la comunidad es difícil de apreciar. Por ejemplo, es relativamente habitual que uno abra un issue en Github pidiendo una nueva característica en un paquete, y que los creadores la implementen (e.g. [correlation](https://github.com/easystats/correlation/issues/145), [gtsummary](https://github.com/ddsjoberg/gtsummary/issues/677), [rorcid](https://github.com/ropensci/rorcid/issues/44)), que uno reporte un error y lo corrijan (e.g. [sjPlot](https://github.com/strengejacke/sjPlot/issues/725), [gtsummary](https://github.com/ddsjoberg/gtsummary/issues/686)), recibir correcciones y mejoras en tus repositorios (e.g. [html2latex](https://github.com/gorkang/html2latex/pull/1), [2019-Chile](https://github.com/gorkang/2019-Chile/pull/1)), o poder contribuir a repositorios de otros (e.g. [jsPsych](https://github.com/jspsych/jsPsych/pull/1212), [gtsummary](https://github.com/ddsjoberg/gtsummary/pull/683)).  

Sus funciones de visualización son muy potentes (ver la [r-graph-gallery](https://www.r-graph-gallery.com/) para algunos ejemplos), siendo usadas como herramienta principal en medios como la [BBC](https://medium.com/bbc-visual-and-data-journalism/how-the-bbc-visual-and-data-journalism-team-works-with-graphics-in-r-ed0b35693535).  


![SOURCE: [BBC](https://medium.com/bbc-visual-and-data-journalism/how-the-bbc-visual-and-data-journalism-team-works-with-graphics-in-r-ed0b35693535)](`r here::here("data", "images", "BBC.png")`)

<BR> 

No menos importante, hay una gran cantidad de cursos, tutoriales, presentaciones y libros de una calidad excelente, con los que podemos aprender de manera autónoma. Por ejemplo:

- [psyTeachR team at the University of Glasgow](https://psyteachr.github.io/)
- [A Gentle Guide to the Grammar of Graphics with ggplot2](https://pkg.garrickadenbuie.com/gentle-ggplot2/)
- [resulumit.com Rmd workshop](https://resulumit.com/teaching/rmd_workshop.htm)
- [R for Data Science](https://r4ds.had.co.nz/)
- [Advanced R](https://adv-r.hadley.nz/)

<BR>    

Con R puedes recoger datos interactivamente con [shiny](https://shiny.rstudio.com/), preparar datos (o extraerlos de paginas web con [rvest](https://github.com/tidyverse/rvest) o [RSelenium](https://github.com/ropensci/RSelenium)), visualizar datos estáticos con [ggplot](https://ggplot2.tidyverse.org/), animarlos con [gganimate](https://github.com/thomasp85/gganimate), visualizarlos con interactivamente con [plotly](https://github.com/ropensci/plotly/) o [shiny](https://shiny.rstudio.com/). Puedes también analizar los datos con todas las técnicas imaginables, desde anovas con [afex](https://github.com/singmann/afex) a modelos mixtos con [lmer](https://github.com/lme4/lme4) y/o [afex](https://github.com/singmann/afex), pasando por meta-análisis con [metafor](http://www.metafor-project.org/doku.php), SEM, Path analysis, mediación, con [lavaan](http://lavaan.ugent.be/tutorial/sem.html), análisis Bayesianos con [brms](https://github.com/paul-buerkner/brms) o [bayesfactor](http://bayesfactor.blogspot.com/), y un larguísimo etc. Puedes llevar tus visualizaciones y análisis a reportes automáticos en múltiples formatos (pdf, html, docx) con [Rmarkdown](https://rmarkdown.rstudio.com/), crear libros como este con [bookdown](https://bookdown.org/), páginas web con [blogdown](https://bookdown.org/yihui/blogdown/) o [distill](https://rstudio.github.io/distill/), e incluso papers completamente reproducibles (preparación y análisis de datos) en formato APA con [papaja](https://github.com/crsh/papaja).  

<BR>   


### Bienvenida al tidyverse

<div style= "float:left;position: relative; margin:0px 30px 0px 0px;">
![](`r here::here("data/images/tidyverse-logo.png")`)
</div>

El [tidyverse](https://www.tidyverse.org/) es un conjunto de paquetes que nos permitirán hacer de manera (habitualmente) intuitiva muchas tareas de preparación y visualización de datos.    



#### Tidyverse vs Base R

Muchas de las funciones que existen en el Tidyverse tienen un [equivalente en base-R](https://tavareshugo.github.io/data_carpentry_extras/base-r_tidyverse_equivalents/base-r_tidyverse_equivalents.html) (la instalación por defecto de R). El Tidyverse tiene ventajas y desventajas. La ventaja fundamental es que el código resulta (habitualmente) más fácil de leer, los nombres de las funciones son mas intuitivos, y las maneras de hacer las cosas tienen a ser consistentes. La desventaja fundamental es que [incrementamos el numero de dependencias](http://www.tinyverse.org/) (paquetes) de nuestro código.  


Veamos un ejemplo extraído de [aqui](https://tavareshugo.github.io/data_carpentry_extras/base-r_tidyverse_equivalents/base-r_tidyverse_equivalents.html). La misma operación con base-R o con tidyverse:    

*Filter rows with conditions evaluated within groups: iris flowers with maximum “Petal.Width” for each “Species”*  

**Tidyverse**  
```{r tidyverse-vs-base-R-02, eval=FALSE}
  iris %>% 
    group_by(Species) %>% 
    filter(Petal.Width == max(Petal.Width))

```

**Base-R**
```{r tidyverse-vs-base-R-01}
  # First operate in the data.frame by group (split-apply)
  widest_petals <- by(iris, 
                      INDICES = iris$Species, 
                      FUN = function(x){
                        x[x$Petal.Width == max(x$Petal.Width), ] 
                      })
  
  # Then combine the results into a data.frame
  do.call(rbind, widest_petals)
```


### Antes de empezar

Programar es muy difícil. Todos necesitamos ayuda. Contar con una comunidad robusta con la que compartir, preguntar, contribuir, ayuda muchísimo.

![SOURCE: http://www.keywordbasket.com/ZWZlY3RvIGR1bm5pbmcta3J1Z2Vy/](`r here::here("data", "images", "dunning-kruger.jpg")`)  

<BR> 

Hay algunos recursos que son **imprescindibles**. Nadie sabe como *los antiguos* podían programar antes de la llegada de Stackoverflow:  

* [**Stack overflow**](https://stackoverflow.com/questions/tagged/r)   

* [Google](https://www.google.com/): text size ggplot  


Y otros recursos que resultan muy útiles:

* [Comunidad de usuarios de Rstudio](https://community.rstudio.com/)  

* [Twiter!](https://twitter.com/home) Por ejemplo:  
    + [![](`r here::here('data/images', 'twitter_small.png')`) \@thomas_mock](https://twitter.com/thomas_mock) (#TidyTuesday)  
    + [![](`r here::here('data/images', 'twitter_small.png')`) \@dataandme](https://twitter.com/dataandme)  
    + [![](`r here::here('data/images', 'twitter_small.png')`) \@rivaquiroga](https://twitter.com/rivaquiroga)  
    + [![](`r here::here('data/images', 'twitter_small.png')`) \@RLadiesSantiago](https://twitter.com/RLadiesSantiago)  
    

* Webs como [R bloggers](https://www.r-bloggers.com/)  




### R para visualización de datos

[ggplot2](https://ggplot2.tidyverse.org/) es el paquete por excelencia para visualización de datos. Su potencia va asociada a un nivel de complejidad considerable, hasta el punto que hay [Cheat sheets oficiales](https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf), [Cheat sheets buscables](https://www.computerworld.com/article/2935394/my-ggplot2-cheat-sheet-search-by-task.html), y decenas de miles de preguntas en [Stack Overflow](https://stackoverflow.com/questions/tagged/ggplot2).  


#### Primeros pasos - con training wheels

Para empezar a usar ggplot sin tener que preocuparnos de su complejidad, podemos usar la función `esquisse:::esquisser()` del paquete [esquisse](https://github.com/dreamRs/esquisse). Esta nos permite usar la potencia de ggplot para explorar una base de datos de manera muy sencilla.   

![SOURCE: https://www.williamrchase.com/slides/intro_r_anthropology_2018#93](`r here::here("data", "images", "esquisse.gif")`)  

<!-- (https://www.williamrchase.com/slides/slide_img/esquisse.gif)   -->  

<BR> 

La manera fácil (1, 2, 3), usando [esquisse](https://github.com/dreamRs/esquisse):  

```{r visualizacion_0, eval=FALSE}

# 1) Asegúrate que hemos instalado el paquete esquisse
  if (!require('esquisse')) install.packages('esquisse'); library('esquisse')

# 2) Lanza el wizard esquisser  
  esquisse:::esquisser(iris)

# 3) Crea el gráfico que quieras, exporta el código...

```

#### Aprendamos con Garrick 

[Garrick Aden-Buie](https://www.garrickadenbuie.com/) ([![](`r here::here('data/images', 'twitter_small.png')`) \@grrrck](https://twitter.com/grrrck)) ha creado una excelente [introducción a ggplot2 y la gramática de gráficos](https://pkg.garrickadenbuie.com/gentle-ggplot2/#28). Os recomiendo revisarla para familiarizaros con las funcionalidades de ggplot.  
<!-- https://github.com/gadenbuie/gentle-ggplot2  -->



## Visualización de datos con ggplot2 


### Primeros pasos

En esta sección vamos a ver algunos de los componentes que usaremos cuando visualicemos datos. Muchos de los ejemplos que usaremos vienen de [R for data science](https://r4ds.had.co.nz/data-visualisation.html).  

Los ingredientes esenciales de una gráfica son:  


###### {.parameters -}    

* **Aesthetic mappings** (aes): Variables, colores, rellenos, formas, ...
* **Geoms** (geom_): puntos, líneas, boxplots, ...
* **Facets** (facet_): facet_wrap() y facet_grid()
* **Transformaciones estadísticas**: stat_summary, ..prop.., ...

![SOURCE: https://skillgaze.com/2017/10/31/understanding-different-visualization-layers-of-ggplot/](`r here::here("data", "images", "visualization-layers-of-ggplot.png")`)  

---  


En ggplot, después de indicar los datos y coordenadas (e.g. `ggplot(data = mpg, aes(x = displ, y = hwy))`), podemos sumar uno o varios `geoms` con una lógica de capas superpuestas, por ejemplo ` + geom_point()`:

```{r geoms-example-01, echo=FALSE}

  plot1 = ggplot(mpg, aes(displ, hwy)) +
    labs(subtitle = "\nggplot(mpg, aes(displ, hwy))")
  
  
  plot2 = ggplot(mpg, aes(displ, hwy)) +
    geom_point() +
    labs(subtitle = "\nggplot(mpg, aes(displ, hwy)) + 
    geom_point()")
  

  plot3 = ggplot(mpg, aes(displ, hwy)) +
  geom_point() + 
  geom_smooth() +
    labs(subtitle = "\nggplot(mpg, aes(displ, hwy)) + 
    geom_point() +
    geom_smooth()")


  cowplot::plot_grid(plot1, plot2, plot3, nrow = 1)
  
```


---  


### Aesthetic mappings

En **aes()** vamos a indicar las variables que queremos en los ejes x e y, el color de los puntos o líneas, el relleno de las barras, la forma de los puntos, el tipo de linea, la agrupación de los datos, etc.  



###### {.parameters -}    

* **x**: x = gdpPercap
* **y**: y = lifeExp
* **color**: color = continent; color = "red"; color = "#FAA627"
* **fill**: fill = continent; fill = "red"; fill = "#FAA627"
* **alpha**: alpha = continent; alpha = 0.2
* **size**: size = continent; size = 5
* **shape**:  shape = continent; shape = 0 [ver codigo de las distintas formas](https://r4ds.had.co.nz/data-visualisation.html#fig:shapes)
* **linetype**: linetype = continent; linetype = "dashed"
* **group**: group = continent



#### x-y

Usando los datos de gapminder, visualizamos la relación entre gdpPercap (eje x), y lifeExp (eje y).  

```{r aes}
ggplot(data = gapminder, 
         mapping = aes(x = gdpPercap, y = lifeExp)) + 
    geom_point()
```

Si respetamos el orden, podemos simplificar nuestro código, evitando el `data =` y `mapping =`. En este caso, vemos de nuevo lifeExp y gdpPercap, invirtiendo los ejes.  

```{r aes2}

  ggplot(gapminder, aes(lifeExp, gdpPercap)) + 
    geom_point()
```


#### Ejercicio {.ejercicio -}

Usando `gapminder`, ¿podrías crear un gráfico de gdp per cápita por población como éste?

```{r ejercicio_xy, echo=FALSE}

ggplot(gapminder, aes(gdpPercap, pop)) + 
    geom_point()

```
  

#### Color, alpha, size

* Para elegir paletas de colores: [colorbrewer](http://colorbrewer2.org)  

* [Codigo HEX de colores](https://www.rapidtables.com/web/color/RGB_Color.html#color-picker)  


```{r color}

  # Gráfico inicial
  ggplot(gapminder, aes(gdpPercap, lifeExp)) + 
    geom_point()
  
  # Color "rojo" para los puntos
  ggplot(gapminder, aes(gdpPercap, lifeExp)) + 
    geom_point(color = "red")
  
  # Color en función de la variable 'continent'
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) + 
    geom_point()
  
  # Color en función de la variable 'continent' + size
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent, size = 2)) + 
    geom_point()
  
  # Color en función de la variable 'continent' + size + alpha
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent, size = 2, alpha = .1)) + 
    geom_point()
  
```

Imagina que queremos asignar colores manualmente. 

```{r color-01, eval=FALSE}

  ggplot(gapminder, aes(gdpPercap, lifeExp)) + 
    geom_point(color = c("red", "grey", "green", "purple", "black")) 
  # Error: Aesthetics must be either length 1 or the same as the data (1704): colour

```

Tenemos que indicar que el color depende de `continent`, y después usar `scale_color_manual()`  

```{r color-01b}

  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) + 
    geom_point() +
    scale_color_manual(values = c("red", "grey", "green", "purple", "black"))

```


#### Ejercicios {.ejercicio -}

Usando como base el plot del ejercicio anterior (GDP x población), ¿podrías hacer lo siguiente?  

- Colorear los puntos por continente
- Tamaño del punto 4
- Alpha 0.5


```{r ejercicio_point1, echo=FALSE}

ggplot(gapminder, aes(gdpPercap, pop, color = continent)) + 
    geom_point(size = 4, alpha = .5)

```


Cada uno de los siguientes gráficos tiene un error. ¿Sabrias corregirlos?

<details><summary>Solucion: ![](data/images/hint.png)</summary><span style="color: orange;">color = continent debe ir dentro de aes()</span></details>

```{r ejercicio_point2, echo=TRUE}
ggplot(gapminder, aes(gdpPercap, pop), color = continent) + 
    geom_point(size = 4, alpha = .5)
```

<details><summary>Solución: ![](data/images/hint.png)</summary><span style="color: orange;">color = "blue" debe ir fuera de aes()</span></details>

```{r ejercicio_point3, echo=TRUE}
ggplot(gapminder, aes(gdpPercap, pop, color = "blue")) + 
    geom_point(size = 4, alpha = .5)
```


<BR>


#### Shape {#shape}

**Códigos para las distintas formas**:  

###### {.parameters -}    

![SOURCE: https://r4ds.had.co.nz/data-visualisation.html#aesthetic-mappings](`r here::here("data", "images", "shapes-1.png")`)

###### {-}   


En este ejemplo usamos la variable `continent` para que cada asignar una forma diferente a cada uno de los continentes.  


```{r shape, message=TRUE, warning=TRUE}

  ggplot(gapminder, aes(gdpPercap, lifeExp, shape = continent)) + 
    geom_point() 

```



#### Linetype  

**Códigos para los distintos estilos de linea**:  

###### {.parameters -}    

![SOURCE: http://sape.inf.usi.ch/quick-reference/ggplot2/linetype](`r here::here("data", "images", "ggplot2-linetype-identity.png")`)  

###### {-}    

<BR>
Podemos definir directamente el tipo de línea que queremos en `geom_line()`:  

```{r linetype-1}

  ggplot(gapminder, aes(year, lifeExp, color = continent)) + 
    stat_summary(fun = mean, geom = "line", linetype = "dashed")


```

O que el tipo de línea dependa de una variable:  

```{r linetype-2}

  ggplot(gapminder, aes(year, lifeExp, linetype = continent, color = continent)) + 
    stat_summary(fun = mean, geom = "line") 

```


### Geoms

Una de las cosas más difíciles cuando nos enfrentamos a nuevos datos es elegir el método más efectivo para visualizarlos. Hay varios recursos interesantes sobre [cómo elegir una gráfica](https://github.com/widged/data-for-good/wiki/Visualisation-::-Choosing-a-chart). En esta sección veremos distintos tipos de geometría, o `geoms_()`.  

---  


**Algunos tipos de geoms**  

Para una lista exhaustiva ver el [manual de ggplot2](https://ggplot2.tidyverse.org/reference/).  

###### {.parameters -}    

![SOURCE: https://nbisweden.github.io/RaukR-2019/ggplot/presentation/ggplot_presentation_assets/geoms.png](`r here::here("data", "images", "geoms.png")`)  

<!-- `geom_abline()`, `geom_area()`, `geom_bar()`, `geom_bin2d()`, `geom_blank()`, `geom_boxplot()`, `geom_col()`, `geom_contour()`, `geom_contour_filled()`, `geom_count()`, `geom_crossbar()`, `geom_curve()`, `geom_density()`, `geom_density2d()`, `geom_density2d_filled()`, `geom_density_2d()`, `geom_density_2d_filled()`, `geom_dotplot()`, `geom_errorbar()`, `geom_errorbarh()`, `geom_freqpoly()`, `geom_function()`, `geom_hex()`, `geom_histogram()`, `geom_hline()`, `geom_jitter()`, `geom_label()`, `geom_line()`, `geom_linerange()`, `geom_map()`, `geom_path()`, `geom_point()`, `geom_pointrange()`, `geom_polygon()`, `geom_qq()`, `geom_qq_line()`, `geom_quantile()`, `geom_raster()`, `geom_rect()`, `geom_ribbon()`, `geom_rug()`, `geom_segment()`, `geom_sf()`, `geom_sf_label()`, `geom_sf_text()`, `geom_smooth()`, `geom_spoke()`, `geom_step()`, `geom_text()`, `geom_tile()`, `geom_violin()`, `geom_vline()`   -->

<BR> 

#### geom_point y geom_jitter

Si queremos un gráfico de dispersión o scatterplot, podemos usar el `geom_point()`  

```{r geoms-point}
  ggplot(mpg, aes(displ, hwy)) + 
    geom_point()
```

En algunos casos, tenemos muchos puntos que se superponen. Si usamos `geom_jitter()` la posición de los puntos cambia levemente de manera aleatoria para evitar superposiciones. Con las propiedades ´width´ y ´height´ podemos controlar cuando desplazamiento queremos horizontal y verticalmente.  

```{r geoms-jitter}
  ggplot(mpg, aes(displ, hwy)) + 
    geom_jitter()
```


#### geom_smooth

Podemos usar líneas de tendencia con `geom_smooth()`. El `method` por defecto es [loess](https://en.wikipedia.org/wiki/Local_regression), pero podemos usar otras funciones (e.g. `geom_smooth(method = "lm")` para usar una regresión lineal).  

```{r geom-smooth}
  
  # Linea de tendencia (default loess)
  ggplot(gapminder, aes(gdpPercap, lifeExp)) + 
    geom_point() +
    geom_smooth()

  # Usamos lm
  ggplot(gapminder, aes(gdpPercap, lifeExp)) + 
    geom_point() +
    geom_smooth(method = "lm")

  # Un smooth por cada clase
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) + 
    geom_point() +
    geom_smooth()

  # Coloreamos puntos pero mantenemos un solo smooth
  ggplot(gapminder, aes(gdpPercap, lifeExp)) + 
    geom_point(aes(color = continent)) +
    geom_smooth()

    
```


#### Ejercicios {.ejercicio -}

Usando como base el plot de la sección [Shape](#shape):  

- Colorear los puntos por continente
- Mostrar una línea de tendencia por continente (sin el intervalo de confianza)
- Que el tipo de línea cambie por continente
- Añadir transparencia para que las líneas destaquen


```{r ejercicio_smooth, echo=FALSE}

  ggplot(gapminder, aes(gdpPercap, lifeExp, shape = continent, color = continent, linetype = continent)) + 
    geom_point(alpha = .3) +
    geom_smooth(se = FALSE) 


```


Usando el df `mpg`, intenta crear los 6 plots que se pueden ver más abajo.  

Aquí tienes el plot base, para hacer mas fácil la tarea:   

```{r geoms-ejercicios-0, fig.height=4, fig.width=6}

ggplot(mpg, aes(displ, hwy)) + 
  geom_point() +
  theme_grey()

```


Además de generar uno a uno los 6 plots, serías capaz de generar la figura que se ve abajo? Esto es, un plot que incluye los 6 plots juntos.  

<details><summary>Solucion: ![](data/images/hint.png)</summary><span style="color: orange;">En la sección [Combinando gráficas](#combinando-graficas) veras un ejemplo del uso de la función cowplot::plot_grid()</span></details>  



```{r geoms-ejercicios, echo=FALSE, fig.height=12, fig.width=12}

plot1 = ggplot(mpg, aes(displ, hwy)) + 
    geom_point() +
    geom_smooth(se = FALSE) +
    theme_grey()

plot2 = ggplot(mpg, aes(displ, hwy, group = drv)) + 
    geom_point() +
    geom_smooth(se = FALSE) +
    theme_grey()

plot3 = ggplot(mpg, aes(displ, hwy, color = drv)) + 
    geom_point() +
    geom_smooth(se = FALSE) +
    theme_grey()

  
plot4 = ggplot(mpg, aes(displ, hwy)) + 
    geom_point(aes(color = drv)) +
    geom_smooth(se = FALSE) +
    theme_grey()

plot5 = ggplot(mpg, aes(displ, hwy, linetype = drv)) + 
    geom_point(aes(color = drv)) +
    geom_smooth(se = FALSE) +
    theme_grey()

  
plot6 = ggplot(mpg, aes(displ, hwy)) + 
    geom_point(color = "white", size = 6) +
    geom_point(aes(color = drv), size = 2) +
    theme_grey()


cowplot::plot_grid(plot1, plot2, plot3, plot4, plot5, plot6,
                   ncol = 2)  

```

<BR> 

#### geom_boxplot y geom_violin

Podemos crear diagramas de cajas (boxplots) con `geom_boxplot` o violines con `geom_violin` para visualizar como cambian los datos por grupo.  

```{r geoms-boxplot-violin}

  # Boxplot con fill
  ggplot(gapminder, aes(continent, lifeExp, fill = continent)) + 
    geom_boxplot(alpha = .2)

  # Violins  
  ggplot(gapminder, aes(continent, lifeExp, fill = continent)) + 
    geom_violin(alpha = .2)
  
  # Combinamos ambos  
  ggplot(gapminder, aes(continent, lifeExp)) + 
    geom_boxplot(alpha = .2) +
    geom_violin(alpha = .2, aes(fill = continent))

```


#### geom_histogram y geom_bar {#histogramas}

Podemos usar histogramas `geom_histogram()` con variables continuas.  

```{r geom-histogram}
  ggplot(gapminder, aes(lifeExp)) + 
    geom_histogram()
```

O si tenemos variables categóricas, `geom_bar()`.  

```{r geom-bar}
  ggplot(gapminder, aes(continent, fill = continent)) +
    geom_bar(alpha = .6)
```


#### geom_density

Para visualizar distribuciones (cuando tenemos muchos datos), podemos usar `geom_density()`.  

```{r geom-density}
  
  # Density with fill and alpha
  ggplot(gapminder, aes(lifeExp, fill = continent)) + 
      geom_density(alpha = .2)

```


#### Ejercicio {.ejercicio -}

Añadiendo un parámetro a la gráfica de arriba, podemos transformarla en las versiones de abajo. ¿Podrías hacerlo? (recuerda que poníendote encima de `geom_density()` y tecleando `F1` puedes ver la ayuda de la función).  

<details><summary>Solucion: ![](data/images/hint.png)</summary><span style="color: orange;">`position = "stack"` y `position = "fill"`.</span></details>

```{r ejercicio-density, echo=FALSE}

  # Density - position stack
  ggplot(gapminder, aes(lifeExp, fill = continent)) + 
      geom_density(position = "stack", alpha = .2)
  
  # Density - position fill
  ggplot(gapminder, aes(lifeExp, fill = continent)) + 
      geom_density(position = "fill", alpha = .2)
  
```


#### geom_density_ridges

Uno de mis geoms favoritos para comparar distribuciones es `geom_density_ridges`:   

```{r geom-density_ridges}
# geom_density_ridges
  ggplot(gapminder, aes(lifeExp, continent, fill = continent)) + 
    ggridges::geom_density_ridges(alpha = .2)
```

Especialmente porque podemos incluir en el mismo gráfico información sobre distribuciones y puntos individuales.  

```{r geom-density_ridges2}
# geom_density_ridges junto con raincloud points y histograma
  ggplot(gapminder, aes(lifeExp, continent, fill = continent)) + 
     ggridges::geom_density_ridges(stat = "binline", bins = 20, scale = 0.95, draw_baseline = FALSE) +
     ggridges::geom_density_ridges(jittered_points = TRUE, position = "raincloud", alpha = 0.7, scale = 0.9)
```



#### Ejercicios {.ejercicio -}

Usando como base el plot de la seccion [geom_histogram()](#histogramas):  

- Colorea los puntos por continente
- Sabrias hacer que no se amontonen unos continentes sobre otros? Necesitarás añadir transparencia para ver todos los datos
<details><summary>Solucion: ![](data/images/hint.png)</summary><span style="color: orange;">`geom_histogram(position = "identity", alpha = .3)`.</span></details>


```{r ejercicio_histogram, echo=FALSE}
ggplot(gapminder, aes(lifeExp, fill = continent)) + 
    geom_histogram()

ggplot(gapminder, aes(lifeExp, fill = continent)) + 
    geom_histogram(position = "identity", alpha = .3)

```


Con el DF `diamonds`, crea el siguiente plot:  
<details><summary>Pista: ![](data/images/hint.png)</summary><span style="color: orange;">Tienes que usar el `geom_bar()` y el parámetro `fill`.</span></details>

```{r geoms-ejercicios-02, echo=FALSE}

ggplot(diamonds) + 
  geom_bar(aes(cut, fill = clarity))

```


<BR>  

### Facets  

Cuando queremos separar en gráficos independientes distintas categorías dentro de nuestros datos, podemos usar facetas. Hay dos funciones para esto,  **facet_grid** y **facet_wrap**.  


#### facet_grid

`facet_grid(~ variable)` nos devuelve una matriz simétrica de gráficas.  

```{r facet_grid}
 
  # Plot inicial
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
    geom_point(alpha = .2) +
    facet_grid(~ continent) +
    guides(alpha = FALSE, color = FALSE)

  # Cambiamos ejes
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
    geom_point(alpha = .2) +
    facet_grid(continent ~ .) +
    guides(alpha = FALSE, color = FALSE)
  
  # Añadimos una segunda variable
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = country)) +
    geom_line(alpha = .2) +
    facet_grid(continent ~ pop > 5000000) +
    guides(alpha = FALSE, color = FALSE)

```


#### facet_wrap

 `facet_wrap(~ variable)` nos devuelve tantas facetas como niveles de la variable, pudiendo definir el número de filas y columnas que queremos.  

```{r facet_wrap}
# Plot base
  ggplot(gapminder, aes(lifeExp, fill = continent)) +
    geom_histogram(alpha = .5) +
    facet_wrap( ~ continent) +
    guides(fill = FALSE)

```

Con la función `gghighlight()` podemos añadir una capa para facilitar la comparación de cada faceta con los datos completos.  

```{r facet_wrap2}
  ggplot(gapminder, aes(lifeExp, fill = continent)) +
    geom_histogram(alpha = .5) +
    facet_wrap( ~ continent, nrow = 1) +
    guides(alpha = FALSE, color = FALSE) +
    gghighlight::gghighlight()

```


### Transformaciones estadísticas  

ggplot2 nos permite hacer algunas transformaciones estadísticas al crear los gráficos. Para más detalles, ver [r4ds](https://r4ds.had.co.nz/data-visualisation.html#statistical-transformations).  


#### stat_summary 

**Algunas funciones que podemos usar en los gráficos**  

###### {.parameters -}  

- **min()**: mínimo
- **max()**: máximo
- **mean()**: media
- **median()**: mediana
- **sd()**: desviación estandar

###### {-}  

Podemos usar funciones simples de manera directa. En este caso, mostramos un punto con la mediana, y barras que muestran el rango completo de los datos:  

```{r transformaciones-estadisticas-stat_summary-1}

  ggplot(gapminder, aes(continent, lifeExp)) + 
    stat_summary(
      fun.ymin = min,
      fun.ymax = max,
      fun = median)
```

Si queremos usar funciones algo mas complejas, la sintaxis es algo diferente. En este caso mostramos media ± desviación estandar:  

```{r transformaciones-estadisticas-stat_summary-2}

  ggplot(gapminder, aes(continent, lifeExp)) +
    stat_summary(
      fun.ymin = function(x) mean(x) - sd(x),
      fun.ymax = function(x) mean(x) + sd(x),
      fun = mean)
```


#### Promedios por grupo

Lo interesante es que podemos añadir estas transformaciones estadísticas como una capa más en los gráficos. Así que, a este gráfico inicial...  

```{r transformaciones-estadisticas-promedios-grupo-1}
ggplot(mpg) + 
  geom_jitter(aes(x = class, y = hwy), width = 0.2) +
  theme_minimal()
```

Le podemos añadir el promedio por grupo:  

```{r transformaciones-estadisticas-promedios-grupo-2}
ggplot(mpg) + 
  geom_jitter(aes(x = class, y = hwy), width = 0.2) +
  stat_summary(aes(x = class, y = hwy), fun = mean, color = "red", geom = "point", size = 4, alpha = .7) + 
  theme_minimal()
```


O cosas aún más elaboradas:  

```{r transformaciones-estadisticas-promedios-grupo-02}

# Gapminder
ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
  geom_point(alpha = .1) +
  stat_summary(data = gapminder %>% 
                 group_by(continent) %>% 
                 summarise(gdpPercap = mean(gdpPercap),
                           lifeExp  = mean(lifeExp)),
               fun = mean,
               geom = "point",
               size = 4)
    
```




#### Ejercicios {.ejercicio -}

Cuando al plot **A** trato de añadirle líneas para cada `class`, me aparece algo como lo de **B**.  

```{r ejercicio-7a}
plotA = ggplot(mpg, aes(displ, hwy, color = class)) +
  geom_point() +
  theme(legend.position = "bottom")

plotB = ggplot(mpg, aes(displ, hwy, color = class)) +
  geom_point() +
  geom_line() +
  theme(legend.position = "bottom")

cowplot::plot_grid(plotA, plotB, labels = c("A", "B"))
```

Pero en realidad no quiero que las líneas pasen por todos los puntos, sino que muestren el promedio ¿Podrías reproducir el gráfico de abajo?  

```{r ejercicio-7b, echo=FALSE}
  ggplot(mpg, aes(displ, hwy, color = class)) +
    geom_point() +
    stat_summary(fun = mean, geom = "line") +
    theme(legend.position = "bottom")
```


Podrías crear este gráfico? Mostramos mediana ± sd para cada país, organizado por continente.

```{r ejercicio-8, echo=FALSE}

  ggplot(gapminder, aes(country, lifeExp, color = continent)) + 
    stat_summary(
      fun.min = function(x) median(x) - sd(x),
      fun.max = function(x) median(x) + sd(x),
      fun = mean) +
  facet_grid(~ continent) +
  theme(axis.text.x = element_blank())

```
<BR>

### Personalización de gráficas

Habitualmente, un vez hemos creado la gráfica, querremos personalizar varias cosas, como las escalas, colores, estilos, título,  etc.  


#### Coordenadas


```{r personalizacion-graficas-coord}

  # Gráfico inicial
  ggplot(gapminder, aes(continent)) +
      geom_bar()

  # coord_flip()
  ggplot(gapminder, aes(continent)) +
    geom_bar() +
    coord_flip()

  # coord_polar()
  ggplot(gapminder, aes(continent)) +
    geom_bar() +
    coord_polar()

```



#### Scales  

```{r personalizacion-graficas-axis}
  
  # Grafico inicial
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
    geom_point(alpha = .1) 
  
  # Añadimos breaks en eje y
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
    geom_point(alpha = .1) +
    scale_y_continuous(breaks = seq(0, 100, 5))
  
  # Definimos cuantos breaks queremos
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
    geom_point(alpha = .1) +
    scale_x_continuous(n.breaks = 20, guide = guide_axis(angle = 90)) +
    scale_y_continuous(n.breaks = 20)
  
  # Separador de miles y breaks en x
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
    geom_point(alpha = .1) +
    scale_y_continuous(breaks = seq(0, 100, 5)) +
    scale_x_continuous(labels = scales::comma, n.breaks = 10)
  
  # Formato de $ ($M)
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
    geom_point(alpha = .1) +
    scale_y_continuous(breaks = seq(0, 100, 5)) +
    scale_x_continuous(labels = scales::dollar_format(prefix = "$", suffix = "M"),
                       breaks = seq(0, 100000, 20000))
  
  # Escala log
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
    geom_point(alpha = .1) +
    scale_y_continuous(breaks = seq(0, 100, 5)) +
    scale_x_log10(labels = scales::dollar_format(prefix = "$", suffix = "M"))
  
  # Invertimos escala
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
    geom_point(alpha = .1) +
    scale_y_reverse()

  # No mostramos el texto de los breaks de x
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
    geom_point(alpha = .1) +
    scale_y_reverse() +
    theme(axis.text.x = element_blank())

  # Porcentaje
  ggplot(gapminder, aes(continent, ..prop.., group = 1)) + 
  geom_bar() +
  scale_y_continuous(labels = scales::percent)
  



```

Usar eje secundario (derecho) para mostrar etiquetas:  

```{r advanced-scales}

gapminder_last = gapminder %>% 
  group_by(continent) %>% 
  filter(year == max(year)) %>% 
  summarize(lifeExp = mean(lifeExp))

ggplot(gapminder, aes(year, lifeExp, linetype = continent, color = continent)) + 
  stat_summary(fun = mean, geom = "line") +
  scale_y_continuous(
    limits = c(0, max(gapminder$lifeExp)),
    expand = c(0,0),
    sec.axis = dup_axis(
      breaks = gapminder_last$lifeExp,
      labels = gapminder_last$continent,
      name = NULL)) +
  scale_x_continuous(expand = c(0,0)) +
  guides(color = "none",
         linetype = "none")

```


#### Ejercicio {.ejercicio -}

El plot del panel (A) tiene varios problemas (los años no son enteros o factores, los casos no se muestran con un separador de miles, la leyenda esta a la derecha ocupado un espacio precioso, etc.). Trata de resolverlos e intenta llegar al resultado que se ve en el panel (B). Usa el dataframe `table1` del paquete {tidyr}?  


```{r geoms-ejercicios-03, echo=FALSE, fig.height=10, fig.width=8}

plot1 = ggplot(table1, aes(year, cases)) + 
  geom_line(aes(group = country), colour = "grey50") + 
  geom_point(aes(colour = country))

plot2 =
  ggplot(table1, aes(as.factor(year), cases)) + 
  geom_line(aes(group = country), colour = "grey50") + 
  geom_point(aes(colour = country), size = 2) +
  scale_y_continuous(labels = scales::comma) +
  scale_x_discrete(expand = c(.05,0)) +
  labs(title = "Casos de Tuberculosis por año",
       x = "year",
       caption = "SOURCE: http://www.who.int/tb/country/data/download/en/") +
  theme(legend.position = "bottom", 
        legend.title = element_blank())

cowplot::plot_grid(plot1, plot2, 
                   nrow = 2,
                   labels = c("A", "B"))

```

Si te sobra tiempo, puedes tratar de reproducir la siguiente versión mejorada...  

```{r geoms-ejercicios-extra,, echo=FALSE, fig.height=5, fig.width=8}
table1_end = table1 %>% filter(year == max(.$year))

  ggplot(table1, aes(as.factor(year), cases)) + 
  geom_line(aes(group = country), colour = "grey50") + 
  geom_point(aes(colour = country), size = 2) +
  scale_y_continuous(limits = c(0, max(table1_end$cases)),
                     labels = scales::comma,
                     expand = c(0.1,0),
                     sec.axis = dup_axis(
                       breaks = table1_end$cases,
                       labels = table1_end$country,
                       name = NULL)) +
  scale_x_discrete(expand = c(.05,0)) +
  labs(title = "Casos de Tuberculosis por año",
       x = "year",
       caption = "SOURCE: http://www.who.int/tb/country/data/download/en/") +
  theme(legend.position = "bottom", 
        legend.title = element_blank()) +
    guides(color = "none") +
    theme_minimal()
  
```


#### Colors and fill scales

```{r personalizacion-graficas-color-fill}

  # Plot inicial
  ggplot(gapminder, aes(continent, lifeExp, fill = continent)) + 
    geom_violin(alpha = .2)

  # Relleno usando paleta blues
  ggplot(gapminder, aes(continent, lifeExp, fill = continent)) + 
    geom_violin(alpha = .2) +
    scale_fill_brewer(palette = "Blues")
  
  # Color grey
  ggplot(iris, aes(Petal.Width, Petal.Length, color = Species)) +
    geom_point() + 
    scale_color_grey(start = 0.2, end = 0.8, na.value = "red")
  
  # Gradient
  ggplot(iris, aes(Petal.Width, Petal.Length, color = Petal.Width)) +
    geom_point() + 
    scale_color_gradient(low = "red", high = "blue")
  
  # Gradient con un numero predefinidos de una paleta
  ggplot(iris, aes(Petal.Width, Petal.Length, color = Petal.Width)) +
    geom_point() + 
    scale_colour_gradientn(colours = terrain.colors(3))
  
```


#### Combinando gráficas {#combinando-graficas}

Con {[cowplot](https://cran.r-project.org/web/packages/cowplot/vignettes/introduction.html#:~:text=The%20cowplot%20package%20is%20a,or%20mix%20plots%20with%20images.)} podemos combinar gráficas de manera muy simple. Otro paquete muy interesante es {[patchwork](https://patchwork.data-imaginist.com/)}.  

```{r personalizando-combinando-basico}

plot1 = ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
  geom_point(alpha = .1) +
  scale_y_continuous(breaks = seq(0, 100, 5)) +
  scale_x_log10(labels = scales::dollar_format(prefix = "$", suffix = "M")) +
  theme(legend.position = "top")

plot2 = ggplot(gapminder, aes(continent, ..prop.., group = 1)) + 
  geom_bar() +
  scale_y_continuous(labels = scales::percent) +
  coord_flip()
  
cowplot::plot_grid(plot2, plot1,
                   rel_widths = c(.3, 0.7))

```

O hacer cosas mas complejas como combinar un [scatteplot con un par de histogramas](https://stackoverflow.com/questions/8545035/scatterplot-with-marginal-histograms-in-ggplot2/56440634#56440634):  

```{r personalizando-combinando-avanzado}

# Set up scatterplot
scatterplot <- ggplot(iris, aes(Sepal.Length, Sepal.Width, color = Species)) +
  geom_point(size = 3, alpha = 0.6) +
  guides(color = FALSE) +
  theme(plot.margin = margin())


# Define marginal histogram
marginal_distribution <- function(x, var, group) {
  ggplot(x, aes_string(x = var, fill = group)) +
    geom_histogram(bins = 30, alpha = 0.4, position = "identity") +
    # geom_density(alpha = 0.4, size = 0.1) +
    guides(fill = FALSE) +
    theme_void() +
    theme(plot.margin = margin())
}

# Set up marginal histograms
x_hist <- marginal_distribution(iris, "Sepal.Length", "Species")
y_hist <- marginal_distribution(iris, "Sepal.Width", "Species") +
  coord_flip()

# Align histograms with scatterplot
aligned_x_hist <- align_plots(x_hist, scatterplot, align = "v")[[1]]
aligned_y_hist <- align_plots(y_hist, scatterplot, align = "h")[[1]]


# Arrange plots
cowplot::plot_grid(
  aligned_x_hist, NULL, scatterplot, aligned_y_hist,
  ncol = 2, nrow = 2, 
  rel_heights = c(0.2, 1), rel_widths = c(1, 0.2)
  )

```

<BR>
#### Usando estilos

Los estilos nos permiten personalizar los gráficos de manera muy sencilla, por ejemplo, usando {[ggtheme](https://ggplot2.tidyverse.org/reference/ggtheme.html)}. Podéis ver un tutorial [aquí](https://michaeltoth.me/you-need-to-start-branding-your-graphs-heres-how-with-ggplot.html).  

Primero creamos un gráfico sobre el que aplicaremos estilos.  

```{r personalizacion-graficas-01}

p <- ggplot(iris, aes(Petal.Width, Petal.Length, color = Species)) +
  geom_point() +
  labs(title = 'A ggplot simple graph',
       subtitle = 'Simple tweaks to improve plots, or not',
       x = '',
       y = '',
       caption = 'https://github.com/gorkang / @gorkang') +
    theme_gray() # This is the default. Needed here because of the Bookdown theme

p

```

Usando el tema fivethirtyeight:  

```{r personalizacion-graficas-02}

p +
  ggthemes::scale_color_fivethirtyeight() +
  ggthemes::theme_fivethirtyeight()

```

Usando el tema economist:  

```{r personalizacion-graficas-03}

p +
  ggthemes::scale_color_economist() +
  ggthemes::theme_economist()

```


#### Ejercicios {.ejercicio -}

Serías capaz de reproducir este gráfico, usando el dataframe `diamonds` y el `theme_economist`? 

```{r ejercicio-6a, echo=FALSE}

ggplot(diamonds, aes(price, cut, fill = cut, color = cut)) +
  ggridges::geom_density_ridges(alpha = .6) +
  scale_x_log10() +
  labs(title = "Distribución de precios (log) en función del tipo de corte",
       caption = "@gorkang",
       x = "price (log)") +
  ggthemes::scale_fill_economist() +
  ggthemes::scale_color_economist() +
  ggthemes::theme_economist() +
  theme(legend.position = "none", 
        text = element_text(size = 14))

```

Serías capaz de reproducir este gráfico, usando el dataframe `gapminder` y la paleta `Accent`? 

```{r ejercicio-6b, echo=FALSE}

ggplot(gapminder, aes(gdpPercap, continent, fill = continent, color = continent)) +
  ggridges::geom_density_ridges(alpha = .6) +
  scale_color_brewer(palette = "Accent") +
  scale_fill_brewer(palette = "Accent") +
  theme(legend.position = "none", 
        text = element_text(size = 14),
        axis.title.y = element_blank()) +
  labs(x = "GDP") +
  scale_x_log10(labels = scales::dollar_format(prefix = "$", suffix = "M"))

```




## Visualización interactiva


#### Gráficas interactivas

```{r graficas-interactivas, fig.height=8, fig.width=8}

plotly::ggplotly(
  ggplot(gapminder %>% filter(year == 2007), aes(gdpPercap, lifeExp, color = continent, size = country)) +
    geom_point(alpha = .3, point = 2) +
    scale_y_continuous(breaks = seq(0, 100, 5)) +
    scale_x_log10(labels = scales::dollar_format(prefix = "$", suffix = "M")) +
  theme(legend.position = "none")
  )

```


#### Animando gráficas

```{r animando-graficas, fig.height=4, fig.width=8, eval=FALSE}

if (!require('gganimate')) remotes::install_github('thomasp85/gganimate'); library('gganimate')
#sudo apt-get install ffmpeg
  
p = ggplot(gapminder, aes(gdpPercap, lifeExp, size = pop, colour = country)) +
  geom_point(alpha = 0.7, show.legend = FALSE) +
  scale_colour_manual(values = country_colors) +
  scale_size(range = c(2, 12)) +
  scale_x_log10() +
  facet_wrap(~continent) +
  # Here comes the gganimate specific bits
  labs(title = 'Year: {frame_time}', x = 'GDP per capita', y = 'life expectancy') +
  transition_time(year) +
  ease_aes('linear')

  animate(p, renderer = ffmpeg_renderer(), height = 6, width = 10, units = "in", res = 300)
# anim_save("name_file.mp4", animation = last_animation())

```

![](data/images/gganimate.mp4){width="100%"}




## Bibliografía {.bibliografia -}

+ Matejka, J., & Fitzmaurice, G. (2017, May). Same stats, different graphs: Generating datasets with varied appearance and identical statistics through simulated annealing. In Proceedings of the 2017 CHI Conference on Human Factors in Computing Systems (pp. 1290-1294). ACM.

+ https://bbc.github.io/rcookbook/  

+ https://github.com/bbc/bbplot  

+ https://github.com/dreamRs/esquisse  

+ Garrick Aden-Buie. A Gentle Guide to the Grammar of Graphics with ggplot2: https://github.com/gadenbuie/gentle-ggplot2

+ Michael Toth. You Need to Start Branding Your Graphs. Here's How, with ggplot!: https://michaeltoth.me/you-need-to-start-branding-your-graphs-heres-how-with-ggplot.html  

+ Claus Wilke: https://wilkelab.org/practicalgg/  

+ Thomas Lin Pedersen: 
  
    + Part 1: https://www.youtube.com/watch?v=h29g21z0a68
    + Part 2: https://www.youtube.com/watch?v=0m4yywqNPVY

+ Big Book or R : https://www.bigbookofr.com/index.html
