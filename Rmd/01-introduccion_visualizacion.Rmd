---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Introducción a R y visualización de datos

---  

#### Paquetes para este capítulo {-}

Para poder ejecutar en tu ordenador el código de los ejemplos y ejercicios de este capítulo vas a necesitar los paquetes siguientes. Te recomiendo que abras un script de R, pegues estas líneas al principio y las ejecutes (CNTRL + ENTER para ejecutar linea a linea).    

```{r setup, echo=TRUE}

if (!require('cowplot')) install.packages('cowplot'); library('cowplot')
if (!require('dplyr')) install.packages('dplyr'); library('dplyr')
if (!require('esquisse')) install.packages('esquisse'); library('esquisse') 
if (!require('gapminder')) install.packages('gapminder'); library('gapminder')
if (!require('geomtextpath')) install.packages('geomtextpath'); library('geomtextpath')
if (!require('gghighlight')) install.packages('gghighlight'); library('gghighlight')
if (!require('ggplot2')) install.packages('ggplot2'); library('ggplot2')
if (!require('ggthemes')) install.packages('ggthemes'); library('ggthemes')
if (!require('ggridges')) install.packages('ggridges'); library('ggridges')
if (!require('knitr')) install.packages('knitr'); library('knitr')
if (!require('plotly')) install.packages('plotly'); library('plotly')
if (!require('purrr')) install.packages('purrr'); library('purrr')
if (!require('readr')) install.packages('readr'); library('readr')
if (!require('sjPlot')) install.packages('sjPlot'); library('sjPlot')
if (!require('tidyr')) install.packages('tidyr'); library('tidyr')

```  


---  

## Introducción: porque la visualización de datos es importante


*"These 13 datasets (the Datasaurus, plus 12 others) each have the same summary statistics (x/y mean, x/y standard deviation, and Pearson's correlation) to two decimal places, while being drastically different in appearance."* (Matejka, J., & Fitzmaurice, G., 2017)  


![SOURCE: https://www.autodeskresearch.com/publications/samestats](`r here::here("data", "images", "DinoSequentialSmaller.gif")`)



### Ejemplo del mundo real: ¿cuantos temas deberia estudiar?

Este ejemplo viene de un experimento que realizamos junto con [Carlos Santamaría](https://scholar.google.es/citations?user=fUHQA3gAAAAJ&hl=es) hace algún tiempo. Presentamos una tarea sobre cálculo de probabilidades a personas que estaban entrando a un examen para convertirse en trabajadores del estado. Simplificando algo, digamos que la materia para el examen eran 80 temas. No es posible estudiar con profundidad todos los temas, así que los opositores se concentraban en un subconjunto de esos temas (e.g. 30 de 80). Al empezar el examen, se seleccionaban al azar 5 de los 80 temas, y cada persona elegía uno de ellos para desarrollar.  

Abajo se puede ver como cambia la probabilidad de que uno de los temas estudiados aparezca dentro de los 5 seleccionados al azar. Con 30 de los 80 temas estudiados, la probabilidad de que uno de ellos salga en la prueba es del 91%. Si estudiáramos 47, subiríamos a una probabilidad del 99%.    

```{r opositores-plot, echo=FALSE, fig.height=6, fig.width=8}

hipergeometric_formula <- function(temas_totales = 80,
                 temas_estudiados = 30,
                 temas_seleccionados = 5,
                 temas_estudiados_salen = 1:5) {

  temas_NO_estudiados = temas_totales - temas_estudiados # Temas NO estudiados

  if (temas_estudiados > temas_totales) {
    NA
  } else {
    sum(
      ((factorial(temas_estudiados) / (factorial(temas_estudiados_salen) * (factorial(temas_estudiados - temas_estudiados_salen)))) *
         (factorial(temas_NO_estudiados) / ((factorial(temas_seleccionados - temas_estudiados_salen)) * (factorial(temas_NO_estudiados - (temas_seleccionados - temas_estudiados_salen))))))
      /
      (factorial(temas_estudiados + temas_NO_estudiados) / (factorial(temas_seleccionados) * factorial(temas_estudiados + temas_NO_estudiados - temas_seleccionados))),
      na.rm = TRUE)
  }

}

temas_totales = 80
data_plot = 1:temas_totales %>% purrr::map_dfr(~ hipergeometric_formula(temas_totales = temas_totales, temas_estudiados = .x) %>% as_tibble() %>% mutate(N = .x))


plotly::ggplotly(
  ggplot(data_plot, aes(N, value)) +
    geom_line() +
    geom_vline(xintercept = 30, linetype = "dashed") +
    geom_hline(yintercept = 1, linetype = "dashed") +
    scale_x_continuous(n.breaks = 10) +
    scale_y_continuous(breaks = seq(0, 1, .05), labels = scales::percent(x = seq(0, 1, .05), accuracy = 1)) +
    labs(title = "Probabilidad de que uno de los temas estudiados aparezca",
         x = "Temas estudiados",
         y = "Probabilidad"))

  
```

<BR>
En el experimento le preguntamos a las personas por la probabilidad de que les apareciera alguno de los temas estudiados en la prueba. Comparamos las siguientes dos preguntas:  

+ ¿Cuál es la probabilidad de que **salga uno** de los temas que has estudiado?  
+ ¿Cuál es la probabilidad de que **no salga ninguno** de los temas que has estudiado?  

Miramos el error promedio en función de la pregunta (cuanto se han alejado de la probabilidad correcta), y vimos que nuestra manipulación había tenido un efecto considerable:  

```{r visualizacion-importante-01, echo=FALSE}

# Leemos datos
DF = read_csv(
  here::here("data", "files", "01-visualizacion-importante.csv")) %>% 
  mutate(Question = as.factor(
    case_when(Question_p_of == 1 ~ "p (salga uno)",
              Question_p_of == 0 ~ "p (no salga ninguno)")))

# Promedio por condición
DF %>% 
  group_by(Question) %>% 
  summarise(Error_promedio = mean(Error),
            SD = sd(Error, na.rm = TRUE),
            N = n()) %>% 
  knitr::kable()

```

<BR>

Hay una diferencia notable entre condiciones. Pasamos de un error promedio del -30.7% a tan solo 4%, simplemente cambiando la pregunta. Hagamos un sencillo análisis de regresión para ver si la diferencia es significativa, y cuanta varianza explica nuestro modelo.   


```{r visualizacion-importante-01b, echo=FALSE}
# Modelo de regresión
modelo_regresion = lm(Error ~ Question, DF)

# Resultados
sjPlot::tab_model(modelo_regresion)
# summary(modelo_regresion)
```


```{r visualizacion-importante-01c, echo=FALSE}
# Histograma de los residuos
hist(modelo_regresion$residuals)

# Supuesto de normalidad de residuales
shapiro.test(modelo_regresion$residuals)
```

<BR>
<details><summary>Todo es hermoso. Tenemos un efecto claramente significativo de la pregunta (y con un R2-ajustado de .258, no está nada mal), y además, nuestro modelo no incumple el supuesto de normalidad de residuos (por los pelos!). Léeme ![](data/images/hint.png)</summary><span style="color: orange;">[Las pruebas de normalidad son muy sensibles al n de la muestra](https://stats.stackexchange.com/questions/2492/is-normality-testing-essentially-useless)</span></details>   
Preparamos un plot con promedios y barras con error standard para nuestro paper.

```{r visualizacion-importante-01d, echo=FALSE}

# Plot para publicación
plot_inicial = ggplot(DF, aes(Question, Error, fill = Question)) +
  stat_summary(
    fun = mean,
    geom = "point",
    size = 4,
    color = "darkgrey") +
  stat_summary(geom = "errorbar", fun.data = mean_se, position = "dodge", color = "black", width = .2) +
  scale_y_continuous(limits = c(-50, 50), breaks = seq(-50, 50, 10)) +
  theme_minimal(base_size = 12) +
  labs(x = "What is the probability of x?") +
  theme(legend.position = "none")

plot_inicial

```

Estamos listos para escribir el paper.  Preparemos la tabla con descriptivos...

```{r visualizacion-importante-03, echo=FALSE}

# Promedio y mediana por condición
DF %>% 
  group_by(Question) %>% 
  summarise(Error_promedio = mean(Error),
            # Error_mediana = median(Error),
            SD = sd(Error, na.rm = TRUE),
            N = n()) %>% 
  knitr::kable()

```

---  


Es curioso que la desviación estandard sea mayor en el grupo con menos error promedio... Visualicemos las respuestas de todos los participantes, junto con la distribución de los datos.  

```{r visualizacion-importante-04, echo=FALSE}

plot_final = ggplot(DF, aes(Error, Question, fill = Question, color = Question)) + 
  ggridges::geom_density_ridges(stat = "binline", bins = 20, scale = 0.8, draw_baseline = FALSE, alpha = .6) +
  ggridges::geom_density_ridges(jittered_points = TRUE, position = "raincloud", alpha = 0.7, scale = 0.9) +
  theme_minimal() +
  theme(legend.position = "none") +
  # scale_x_continuous(limits = c(-50, 50), breaks = seq(-50, 50, 10)) +
  labs(y = "What is the probability of x?") +
  coord_flip()

plot_final

```

Como se puede apreciar en la gráfica, cuando usamos la pregunta `¿Cuál es la probabilidad de que no salga ninguno de los temas que has estudiado?` no estamos reduciendo el error, sino convirtiendo una distribución de respuestas unimodal en bimodal.  

---  

**TLDR**: La manera en la visualizamos la información determina las conclusiones a las que llegamos. En una sola gráfica:     

```{r visualizacion-importante-05, fig.width=12, echo=FALSE}


# Visualizamos el gráfico inicial y el final, uno al lado del otro
cowplot::plot_grid(plot_inicial, plot_final, labels = c("Antes", "Después"))

```

#### Moraleja: es importante mostrar los datos individuales y/o la distribución de los datos {-}

![SOURCE: https://www.autodeskresearch.com/publications/samestats](`r here::here("data", "images", "BoxViolinSmaller.gif")`)



---  

## Por qué R? 

<div style= "float:left;position: relative; margin:0px 30px 0px 0px;">![](data/images/R_logo.png)</div>

R es [uno de los programas para data science mas populares](http://r4stats.com/articles/popularity/), especialmente usado en la academia. El numero de paquetes que ofrecen funcionalidades de todo tipo no ha dejado de crecer. En 2022 el numero de paquetes en [R-cran](https://cran.r-project.org/web/packages/index.html) ha superado los 20,000 ([ver este buscador de paquetes](https://mran.microsoft.com/packages)), y el ritmo de crecimiento nos acerca a la singularidad... ;)  

<BR>  

<div style="clear: both;"></div>

![SOURCE: https://gist.github.com/daroczig/3cf06d6db4be2bbe3368](`r here::here("data", "images", "number-of-submitted-packages-to-CRAN.png")`)

<!-- (https://gist.githubusercontent.com/daroczig/3cf06d6db4be2bbe3368/raw/b66b0531fb1b86d3e04a003b2e105ad4f147900e/number-of-submitted-packages-to-CRAN.png)   -->

<BR> 

Además de lo anterior, R es un programa de [código abierto](https://en.wikipedia.org/wiki/Open_source) (algo esencial para poder hacer ciencia reproducible), con una [comunidad de usuarios](https://community.rstudio.com/) muy acogedora, y con un importante foco en la [inclusividad](https://qz.com/work/1661486/r-ladies-made-data-science-inclusive/).  

La importancia de la comunidad es difícil de apreciar. Por ejemplo, es relativamente habitual que uno abra un issue en Github pidiendo una nueva característica en un paquete, y que los creadores la implementen (e.g. [correlation](https://github.com/easystats/correlation/issues/145), [gtsummary](https://github.com/ddsjoberg/gtsummary/issues/677), [rorcid](https://github.com/ropensci/rorcid/issues/44)), que uno reporte un error y lo corrijan (e.g. [sjPlot](https://github.com/strengejacke/sjPlot/issues/725), [gtsummary](https://github.com/ddsjoberg/gtsummary/issues/686)), recibir correcciones y mejoras en tus repositorios (e.g. [html2latex](https://github.com/gorkang/html2latex/pull/1), [2019-Chile](https://github.com/gorkang/2019-Chile/pull/1)), o poder contribuir a repositorios de otros (e.g. [jsPsych](https://github.com/jspsych/jsPsych/pull/1212), [gtsummary](https://github.com/ddsjoberg/gtsummary/pull/683)).  

Sus funciones de visualización son muy potentes (ver la [r-graph-gallery](https://www.r-graph-gallery.com/) para algunos ejemplos), siendo usadas como herramienta principal en medios como la [BBC](https://medium.com/bbc-visual-and-data-journalism/how-the-bbc-visual-and-data-journalism-team-works-with-graphics-in-r-ed0b35693535).  


![SOURCE: [BBC](https://medium.com/bbc-visual-and-data-journalism/how-the-bbc-visual-and-data-journalism-team-works-with-graphics-in-r-ed0b35693535)](`r here::here("data", "images", "BBC.png")`)

<BR> 

No menos importante, hay una gran cantidad de cursos, tutoriales, presentaciones y libros de una calidad excelente, con los que podemos aprender de manera autónoma. Por ejemplo:

- [psyTeachR team at the University of Glasgow](https://psyteachr.github.io/)
- [A Gentle Guide to the Grammar of Graphics with ggplot2](https://pkg.garrickadenbuie.com/gentle-ggplot2/)
- [resulumit.com Rmd workshop](https://resulumit.com/teaching/rmd_workshop.htm)
- [R for Data Science](https://r4ds.had.co.nz/)
- [Advanced R](https://adv-r.hadley.nz/)

<BR>    

Para ver una compilación de todos los libros disponibles: [Big Book of R](https://www.bigbookofr.com/index.html)  

<BR>    

Con R puedes recoger datos interactivamente con [shiny](https://shiny.rstudio.com/), preparar datos (o extraerlos de paginas web con [rvest](https://github.com/tidyverse/rvest) o [RSelenium](https://github.com/ropensci/RSelenium)), visualizar datos estáticos con [ggplot](https://ggplot2.tidyverse.org/), animarlos con [gganimate](https://github.com/thomasp85/gganimate), visualizarlos con interactivamente con [plotly](https://github.com/ropensci/plotly/) o [shiny](https://shiny.rstudio.com/). Puedes también analizar los datos con todas las técnicas imaginables, desde anovas con [afex](https://github.com/singmann/afex) a modelos mixtos con [lmer](https://github.com/lme4/lme4) y/o [afex](https://github.com/singmann/afex), pasando por meta-análisis con [metafor](http://www.metafor-project.org/doku.php), SEM, Path analysis, mediación, con [lavaan](http://lavaan.ugent.be/tutorial/sem.html), análisis Bayesianos con [brms](https://github.com/paul-buerkner/brms) o [bayesfactor](http://bayesfactor.blogspot.com/), y un larguísimo etc. Puedes llevar tus visualizaciones y análisis a reportes automáticos en múltiples formatos (pdf, html, docx) con [Rmarkdown](https://rmarkdown.rstudio.com/), o [quarto](https://quarto.org/), crear libros como este con [bookdown](https://bookdown.org/), páginas web con [blogdown](https://bookdown.org/yihui/blogdown/) o [distill](https://rstudio.github.io/distill/), e incluso papers completamente reproducibles (preparación y análisis de datos) en formato APA con [papaja](https://github.com/crsh/papaja).  

<BR>   


### Bienvenida al tidyverse

<div style= "float:left;position: relative; margin:0px 30px 0px 0px;">
![](`r here::here("data/images/tidyverse-logo.png")`)
</div>

El [tidyverse](https://www.tidyverse.org/) es un conjunto de paquetes que nos permitirán hacer de manera (habitualmente) intuitiva muchas tareas de preparación y visualización de datos.    



#### Tidyverse vs Base R

Muchas de las funciones que existen en el Tidyverse tienen un [equivalente en base-R](https://tavareshugo.github.io/data_carpentry_extras/base-r_tidyverse_equivalents/base-r_tidyverse_equivalents.html) (la instalación por defecto de R). El Tidyverse tiene ventajas y desventajas. La ventaja fundamental es que el código resulta (habitualmente) más fácil de leer, los nombres de las funciones son más intuitivos, y la forma de hacer las cosas tiene a ser consistente. La desventaja fundamental es que [incrementamos el numero de dependencias](http://www.tinyverse.org/) (paquetes) de nuestro código.  


Veamos un ejemplo extraído de [aquí](https://tavareshugo.github.io/data_carpentry_extras/base-r_tidyverse_equivalents/base-r_tidyverse_equivalents.html).  

<BR>  

La misma operación con base-R o con tidyverse:    

*Filter rows with conditions evaluated within groups: iris flowers with maximum “Petal.Width” for each “Species”*  

**Tidyverse**  
```{r tidyverse-vs-base-R-02, eval=FALSE}
  iris %>% 
    group_by(Species) %>% 
    filter(Petal.Width == max(Petal.Width))

```

**Base-R**
```{r tidyverse-vs-base-R-01}
  # First operate in the data.frame by group (split-apply)
  widest_petals <- by(iris, 
                      INDICES = iris$Species, 
                      FUN = function(x){
                        x[x$Petal.Width == max(x$Petal.Width), ] 
                      })
  
  # Then combine the results into a data.frame
  do.call(rbind, widest_petals)
```


### Antes de empezar

Programar es muy difícil. Todos necesitamos ayuda. Contar con una comunidad robusta con la que compartir, preguntar, contribuir, ayuda muchísimo.

![SOURCE: http://www.keywordbasket.com/ZWZlY3RvIGR1bm5pbmcta3J1Z2Vy/](`r here::here("data", "images", "dunning-kruger.jpg")`)  

<BR> 

Hay algunos recursos que son **imprescindibles**. Nadie sabe como *los antiguos* podían programar antes de la llegada de Stackoverflow:  

* [**Stack overflow**](https://stackoverflow.com/questions/tagged/r)   

* [Google: avoid scientific notation R](https://www.google.com/search?q=avoid+scientific+notation+R&oq=avoid+scientific+notation+R&aqs=chrome..69i57j0i22i30l9.5946j0j7&sourceid=chrome&ie=UTF-8): `options(scipen=999)`



Y otros recursos que resultan muy útiles:

* [Comunidad de usuarios de Rstudio](https://community.rstudio.com/)  

* [Twitter!](https://twitter.com/home) Por ejemplo:  
    + [![](`r here::here('data/images', 'twitter_small.png')`) \@thomas_mock](https://twitter.com/thomas_mock) (#TidyTuesday)  
    + [![](`r here::here('data/images', 'twitter_small.png')`) \@dataandme](https://twitter.com/dataandme)  
    + [![](`r here::here('data/images', 'twitter_small.png')`) \@rivaquiroga](https://twitter.com/rivaquiroga)  
    + [![](`r here::here('data/images', 'twitter_small.png')`) \@RLadiesSantiago](https://twitter.com/RLadiesSantiago)  
    
  
* Webs como [R bloggers](https://www.r-bloggers.com/)  




### R para visualización de datos

[ggplot2](https://ggplot2.tidyverse.org/) es el paquete por excelencia para visualización de datos. Su potencia va asociada a un nivel de complejidad considerable, hasta el punto que hay [Cheat sheets oficiales](https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf), [Cheat sheets buscables](https://www.computerworld.com/article/2935394/my-ggplot2-cheat-sheet-search-by-task.html), y decenas de miles de preguntas en [Stack Overflow](https://stackoverflow.com/questions/tagged/ggplot2).  


#### Primeros pasos - con training wheels

Para empezar a usar ggplot sin tener que preocuparnos de su complejidad, podemos usar la función `esquisse:::esquisser()` del paquete [esquisse](https://github.com/dreamRs/esquisse). Esta nos permite usar la potencia de ggplot para explorar una base de datos de manera muy sencilla.   

![SOURCE: https://www.williamrchase.com/slides/intro_r_anthropology_2018#93](`r here::here("data", "images", "esquisse.gif")`)  

<!-- (https://www.williamrchase.com/slides/slide_img/esquisse.gif)   -->  

<BR> 

La manera fácil (1, 2, 3), usando [esquisse](https://github.com/dreamRs/esquisse):  

```{r visualizacion_0, eval=FALSE}

# 1) Asegúrate que hemos instalado el paquete esquisse
  if (!require('esquisse')) install.packages('esquisse'); library('esquisse')

# 2) Lanza el wizard esquisser  
  esquisse:::esquisser(iris)

# 3) Crea el gráfico que quieras, exporta el código...

```

#### Aprendamos con Garrick 

[Garrick Aden-Buie](https://www.garrickadenbuie.com/) ([![](`r here::here('data/images', 'twitter_small.png')`) \@grrrck](https://twitter.com/grrrck)) ha creado una excelente [introducción a ggplot2 y la gramática de gráficos](https://pkg.garrickadenbuie.com/gentle-ggplot2/#28). Os recomiendo revisarla para familiarizaros con las funcionalidades de ggplot.  
<!-- https://github.com/gadenbuie/gentle-ggplot2  -->



## Visualización de datos con ggplot2 


### Componentes de una gráfica

En esta sección vamos a ver algunos de los componentes que usaremos cuando visualicemos datos. Muchos de los ejemplos que usaremos vienen de [R for data science](https://r4ds.had.co.nz/data-visualisation.html).  

Los ingredientes esenciales de una gráfica son:  


###### {.parameters -}    

* **Aesthetic mappings** (aes): Variables, colores, rellenos, formas, ...
* **Geoms** (geom_): puntos, líneas, boxplots, ...
* **Facets** (facet_): paneles con diferentes gráficos para cada nivel de una variable categórica, ...
* **Transformaciones estadísticas**: calcular promedios, barras de error, ...

![SOURCE: https://skillgaze.com/2017/10/31/understanding-different-visualization-layers-of-ggplot/](`r here::here("data", "images", "visualization-layers-of-ggplot.png")`)  

---  

### Mi primera gráfica 1-2-3

Para crear una gráfica con ggplot, tenemos que indicar donde están nuestros datos, que mostraremos en el eje `x` e `y`, además de que geometrias queremos (`geoms`).  Usaremos `+` para sumar instrucciones, con una lógica de capas superpuestas.  

Por ejemplo:  

1) Indicamos los datos y coordenadas: `ggplot(data = mpg, aes(x = displ, y = hwy))`  

2) Añadimos el `geom` de puntos para mostrar la relación entre x e y: ` + geom_point()`  

3) Añadimos un segundo `geom` para trazar  una línea de tendencia: `+ geom_smooth()`  


```{r geoms-example-01, echo=FALSE}

  plot1 = ggplot(mpg, aes(displ, hwy)) +
    labs(subtitle = "\nggplot(mpg, aes(displ, hwy))")
  
  
  plot2 = ggplot(mpg, aes(displ, hwy)) +
    geom_point() +
    labs(subtitle = "\nggplot(mpg, aes(displ, hwy)) + 
    geom_point()")
  

  plot3 = ggplot(mpg, aes(displ, hwy)) +
  geom_point() + 
  geom_smooth() +
    labs(subtitle = "\nggplot(mpg, aes(displ, hwy)) + 
    geom_point() +
    geom_smooth()")


  cowplot::plot_grid(plot1, plot2, plot3, nrow = 1)
  
```


---  


### Aesthetic mappings

En **aes()** vamos a indicar las variables que queremos en los ejes x e y, el color de los puntos o líneas, el relleno de las barras, la forma de los puntos, el tipo de linea, la agrupación de los datos, etc.  



###### {.parameters -}    

* **x**: x = gdpPercap
* **y**: y = lifeExp
* **color**: color = continent; color = "red"; color = "#FAA627"
* **fill**: fill = continent; fill = "red"; fill = "#FAA627"
* **alpha**: alpha = continent; alpha = 0.2
* **size**: size = continent; size = 5
* **shape**:  shape = continent; shape = 0 [ver codigo de las distintas formas](https://r4ds.had.co.nz/data-visualisation.html#fig:shapes)
* **linetype**: linetype = continent; linetype = "dashed"
* **group**: group = continent



#### x-y

Algo esencial es decirle a ggplot que queremos que aparezca en el eje `x` y en el eje `y` de nuestra gráfica.  

Empezaremos usando los datos de gapminder. A ver que variables tenemos en el data-frame `gapminder`:   


```{r datos-gapminder}

gapminder

```


Visualizamos la relación entre gdpPercap (eje x), y lifeExp (eje y):    

```{r aes}
ggplot(data = gapminder, 
         mapping = aes(x = gdpPercap, y = lifeExp)) + 
    geom_point()
```

Si respetamos el orden de las variables, podemos simplificar nuestro código, evitando el `data =` y `mapping =`.   

Por ejemplo, podemos ver de nuevo la relación entre lifeExp y gdpPercap, invirtiendo los ejes.  

```{r aes2}

  ggplot(gapminder, aes(lifeExp, gdpPercap)) + 
    geom_point()
```


#### Ejercicio {.ejercicio -}

Usando `gapminder`, ¿podrías crear un gráfico de gdp per cápita por población como éste?

```{r ejercicio_xy, echo=FALSE}

ggplot(gapminder, aes(gdpPercap, pop)) + 
    geom_point()

```
  

#### Color, alpha, size

Para asignar colores podemos usar nombres de colores en inglés, o algo llamado código HEX:  

* Escribe `colors()` en la Consola de RStudio  

* [Ver el código HEX de los colores](https://www.rapidtables.com/web/color/RGB_Color.html#color-picker)

---  


Empecemos a cambiar parámetros de nuestro gráfico inicial:  

```{r color}

  # Gráfico inicial
  ggplot(gapminder, aes(gdpPercap, lifeExp)) + 
    geom_point()
  
  # Color "rojo" para los puntos
  ggplot(gapminder, aes(gdpPercap, lifeExp)) + 
    geom_point(color = "red")
  
  # Color en función de la variable 'continent'
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) + 
    geom_point()
  
  # Color en función de la variable 'continent'
  # Cambiamos el tamaño de los puntos a 2
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent, size = 2)) + 
    geom_point()
  
  # Color en función de la variable 'continent'
  # Cambiamos el tamaño de los puntos a 2
  # Añadimos transparencia usando el parámetro 'alpha'
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent, size = 2, alpha = .1)) + 
    geom_point()
  
```


#### Ejercicios {.ejercicio -}

Usando como base el plot del ejercicio anterior (GDP x población), ¿podrías hacer lo siguiente?  

- Colorear los puntos por continente
- Tamaño del punto 4
- Alpha 0.5


```{r ejercicio_point1, echo=FALSE}

ggplot(gapminder, aes(gdpPercap, pop, color = continent)) + 
    geom_point(size = 4, alpha = .5)

```


Cada uno de los siguientes gráficos tiene un error. ¿Sabrias corregirlos?

<details><summary>Solucion: ![](data/images/hint.png)</summary><span style="color: orange;">color = continent debe ir dentro de aes()</span></details>

```{r ejercicio_point2, echo=TRUE}
ggplot(gapminder, aes(gdpPercap, pop), color = continent) + 
    geom_point(size = 4, alpha = .5)
```

<details><summary>Solución: ![](data/images/hint.png)</summary><span style="color: orange;">color = "blue" debe ir fuera de aes()</span></details>

```{r ejercicio_point3, echo=TRUE}
ggplot(gapminder, aes(gdpPercap, pop, color = "blue")) + 
    geom_point(size = 4, alpha = .5)
```


<BR>


#### Shape {#shape}

**Códigos para las distintas formas**:  

###### {.parameters -}    

![SOURCE: https://r4ds.had.co.nz/data-visualisation.html#aesthetic-mappings](`r here::here("data", "images", "shapes-1.png")`)

###### {-}   


En este ejemplo usamos la variable `continent` para que cada asignar una forma diferente a cada uno de los continentes.  


```{r shape, message=TRUE, warning=TRUE}

  ggplot(gapminder, aes(gdpPercap, lifeExp, shape = continent)) + 
    geom_point() 

```



#### Linetype  

**Códigos para los distintos estilos de linea**:  

###### {.parameters -}    

![SOURCE: http://sape.inf.usi.ch/quick-reference/ggplot2/linetype](`r here::here("data", "images", "ggplot2-linetype-identity.png")`)  

###### {-}    

<BR>
Podemos definir directamente el tipo de línea que queremos en `geom_line()`:  

```{r linetype-1}

  ggplot(gapminder, aes(year, lifeExp, color = continent)) + 
    stat_summary(fun = mean, geom = "line", linetype = "dashed")


```

O que el tipo de línea dependa de una variable:  

```{r linetype-2}

  ggplot(gapminder, aes(year, lifeExp, linetype = continent, color = continent)) + 
    stat_summary(fun = mean, geom = "line") 

```


## Geoms

Una de las cosas más difíciles cuando nos enfrentamos a nuevos datos es elegir el método más efectivo para visualizarlos. Hay varios recursos interesantes sobre [cómo elegir una gráfica](https://github.com/widged/data-for-good/wiki/Visualisation-::-Choosing-a-chart). En esta sección veremos distintos tipos de geometría, o `geoms_()`.  

---  


**Algunos tipos de geoms**  

Para una lista exhaustiva ver el [manual de ggplot2](https://ggplot2.tidyverse.org/reference/).  

###### {.parameters -}    

![SOURCE: https://nbisweden.github.io/RaukR-2019/ggplot/presentation/ggplot_presentation_assets/geoms.png](`r here::here("data", "images", "geoms.png")`)  

<!-- `geom_abline()`, `geom_area()`, `geom_bar()`, `geom_bin2d()`, `geom_blank()`, `geom_boxplot()`, `geom_col()`, `geom_contour()`, `geom_contour_filled()`, `geom_count()`, `geom_crossbar()`, `geom_curve()`, `geom_density()`, `geom_density2d()`, `geom_density2d_filled()`, `geom_density_2d()`, `geom_density_2d_filled()`, `geom_dotplot()`, `geom_errorbar()`, `geom_errorbarh()`, `geom_freqpoly()`, `geom_function()`, `geom_hex()`, `geom_histogram()`, `geom_hline()`, `geom_jitter()`, `geom_label()`, `geom_line()`, `geom_linerange()`, `geom_map()`, `geom_path()`, `geom_point()`, `geom_pointrange()`, `geom_polygon()`, `geom_qq()`, `geom_qq_line()`, `geom_quantile()`, `geom_raster()`, `geom_rect()`, `geom_ribbon()`, `geom_rug()`, `geom_segment()`, `geom_sf()`, `geom_sf_label()`, `geom_sf_text()`, `geom_smooth()`, `geom_spoke()`, `geom_step()`, `geom_text()`, `geom_tile()`, `geom_violin()`, `geom_vline()`   -->

<BR> 

### geom_point y geom_jitter

Si queremos un gráfico de dispersión o scatterplot, podemos usar el `geom_point()`  

```{r geoms-point}
  ggplot(mpg, aes(displ, hwy)) + 
    geom_point()
```

En algunos casos, tenemos muchos puntos que se superponen. Si usamos `geom_jitter()` la posición de los puntos cambia levemente de manera aleatoria para evitar superposiciones. Con las propiedades ´width´ y ´height´ podemos controlar cuando desplazamiento queremos horizontal y verticalmente.  

```{r geoms-jitter}
  ggplot(mpg, aes(displ, hwy)) + 
    geom_jitter()
```


### geom_smooth

Podemos usar líneas de tendencia con `geom_smooth()`. El `method` por defecto es [loess](https://en.wikipedia.org/wiki/Local_regression), pero podemos usar otros métodos (e.g. `geom_smooth(method = "lm")` para usar una regresión lineal).  

Recuerda que las funciones que usamos (todo lo que contiene `()` e.g. `geom_smooth()`) tienen parámetros, que son instrucciones addicionales que nos permiten modificar como se comportan. Para ver que opciones tenemos, podemos ver la ayuda de las funciones : `?geom_smooth()`, o poner el cursor encima y presionar F1 (ayuda).  

```{r geom-smooth}
  
  # Linea de tendencia (default loess)
  ggplot(gapminder, aes(gdpPercap, lifeExp)) + 
    geom_point() +
    geom_smooth()

  # Usamos lm
  ggplot(gapminder, aes(gdpPercap, lifeExp)) + 
    geom_point() +
    geom_smooth(method = "lm")

  # Un smooth por cada clase
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) + 
    geom_point() +
    geom_smooth()

  # Coloreamos puntos pero mantenemos un solo smooth
  ggplot(gapminder, aes(gdpPercap, lifeExp)) + 
    geom_point(aes(color = continent)) +
    geom_smooth()

    
```


### Ejercicios {.ejercicio -}

Usando como base el plot de la sección [Shape](#shape):  

```
  ggplot(gapminder, aes(gdpPercap, lifeExp, shape = continent)) + 
    geom_point()
```

- Colorea los puntos por continente
- Muestra una línea de tendencia por continente (sin el intervalo de confianza)
- Haz que el tipo de línea cambie por continente
- Añade transparencia a los puntos para que las líneas destaquen


```{r ejercicio_smooth, echo=FALSE}

  ggplot(gapminder, aes(gdpPercap, lifeExp, shape = continent, color = continent, linetype = continent)) + 
    geom_point(alpha = .3) +
    geom_smooth(se = FALSE) 


```


Ahora usando el data-frame `mpg`, intenta crear los 6 plots que se pueden ver más abajo.  

Aquí tienes el plot base, para hacer mas fácil la tarea:   

```{r geoms-ejercicios-0, fig.height=4, fig.width=6}

ggplot(mpg, aes(displ, hwy)) + 
  geom_point() +
  theme_grey()

```


Además de generar uno a uno los 6 plots, serías capaz de generar la figura que se ve abajo? Esto es, un plot que incluye los 6 plots juntos.  

<details><summary>Solucion para combinar plots: ![](data/images/hint.png)</summary><span style="color: orange;">En la sección [Combinando gráficas](#combinando-graficas) veras un ejemplo del uso de la función cowplot::plot_grid()</span></details>  



```{r geoms-ejercicios, echo=FALSE, fig.height=12, fig.width=12}

plot1 = ggplot(mpg, aes(displ, hwy)) + 
    geom_point() +
    geom_smooth(se = FALSE) +
    theme_grey()

plot2 = ggplot(mpg, aes(displ, hwy, group = drv)) + 
    geom_point() +
    geom_smooth(se = FALSE) +
    theme_grey()

plot3 = ggplot(mpg, aes(displ, hwy, color = drv)) + 
    geom_point() +
    geom_smooth(se = FALSE) +
    theme_grey()

  
plot4 = ggplot(mpg, aes(displ, hwy)) + 
    geom_point(aes(color = drv)) +
    geom_smooth(se = FALSE) +
    theme_grey()

plot5 = ggplot(mpg, aes(displ, hwy, linetype = drv)) + 
    geom_point(aes(color = drv)) +
    geom_smooth(se = FALSE) +
    theme_grey()

  
plot6 = ggplot(mpg, aes(displ, hwy)) + 
    geom_point(color = "white", size = 6) +
    geom_point(aes(color = drv), size = 2) +
    theme_grey()


cowplot::plot_grid(plot1, plot2, plot3, plot4, plot5, plot6,
                   ncol = 2)  

```

<BR> 

### geom_boxplot y geom_violin

Podemos crear diagramas de cajas (boxplots) con `geom_boxplot` o violines con `geom_violin` para visualizar como cambian los datos por grupo.  

```{r geoms-boxplot-violin}

  # Boxplot con fill
  ggplot(gapminder, aes(continent, lifeExp, fill = continent)) + 
    geom_boxplot(alpha = .2)

  # Violins  
  ggplot(gapminder, aes(continent, lifeExp, fill = continent)) + 
    geom_violin(alpha = .2)
  
  # Combinamos ambos  
  ggplot(gapminder, aes(continent, lifeExp)) + 
    geom_boxplot(alpha = .2) +
    geom_violin(alpha = .2, aes(fill = continent))

```


### geom_histogram y geom_bar {#histogramas}

Podemos usar histogramas `geom_histogram()` con variables continuas. Como puedes ver, ahora solo le pasamos una variable a `aes()`  

```{r geom-histogram}
  ggplot(gapminder, aes(lifeExp)) + 
    geom_histogram()
```

O si tenemos variables categóricas, `geom_bar()`.  

```{r geom-bar}
  ggplot(gapminder, aes(continent, fill = continent)) +
    geom_bar(alpha = .6)
```


### geom_density

Para visualizar distribuciones (cuando tenemos muchos datos), podemos usar `geom_density()`.  

```{r geom-density}
  
  # Density with fill and alpha
  ggplot(gapminder, aes(lifeExp, fill = continent)) + 
      geom_density(alpha = .2)

```


### Ejercicio {.ejercicio -}

Añadiendo un parámetro a la gráfica de arriba, podemos transformarla en las versiones de abajo. ¿Podrías hacerlo? (recuerda que poníendote encima de `geom_density()` y tecleando `F1` puedes ver la ayuda de la función).  

```
ggplot(gapminder, aes(lifeExp, fill = continent)) + 
      geom_density(alpha = .2)
```

<details><summary>Solucion: ![](data/images/hint.png)</summary><span style="color: orange;">`position = "stack"` y `position = "fill"`.</span></details>

```{r ejercicio-density, echo=FALSE}

  # Density - position stack
  ggplot(gapminder, aes(lifeExp, fill = continent)) + 
      geom_density(position = "stack", alpha = .2)
  
  # Density - position fill
  ggplot(gapminder, aes(lifeExp, fill = continent)) + 
      geom_density(position = "fill", alpha = .2)
  
```


### geom_density_ridges

Uno de mis geoms favoritos para comparar distribuciones es `geom_density_ridges`:   

```{r geom-density_ridges}
# geom_density_ridges
  ggplot(gapminder, aes(lifeExp, continent, fill = continent)) + 
    ggridges::geom_density_ridges(alpha = .2)
```

Especialmente porque podemos incluir en el mismo gráfico información sobre distribuciones y puntos individuales.  

```{r geom-density_ridges2}
# geom_density_ridges junto con raincloud points y histograma
  ggplot(gapminder, aes(lifeExp, continent, fill = continent)) + 
     ggridges::geom_density_ridges(stat = "binline", bins = 20, scale = 0.95, draw_baseline = FALSE) +
     ggridges::geom_density_ridges(jittered_points = TRUE, position = "raincloud", alpha = 0.7, scale = 0.9)
```



### Ejercicios {.ejercicio -}

Usando como base el plot de la seccion [geom_histogram()](#histogramas):  

```
  ggplot(gapminder, aes(lifeExp)) + 
    geom_histogram()
```

- Colorea los histogramas por continente
- Sabrias hacer que no se amontonen unos continentes sobre otros? Necesitarás añadir transparencia para ver todos los datos
<details><summary>Solucion: ![](data/images/hint.png)</summary><span style="color: orange;">`geom_histogram(position = "identity", alpha = .3)`.</span></details>


```{r ejercicio_histogram, echo=FALSE}
ggplot(gapminder, aes(lifeExp, fill = continent)) + 
    geom_histogram()

ggplot(gapminder, aes(lifeExp, fill = continent)) + 
    geom_histogram(position = "identity", alpha = .3)

```


Con el DF `diamonds`, crea el siguiente plot:  

```
  ggplot(diamonds, aes(cut))
```

<details><summary>Pista: ![](data/images/hint.png)</summary><span style="color: orange;">Tienes que usar el `geom_bar()` y el parámetro `fill`.</span></details>

```{r geoms-ejercicios-02, echo=FALSE}

ggplot(diamonds, aes(cut, fill = clarity)) + 
  geom_bar()

```


<BR>  

## Facets  

Cuando queremos separar en gráficos independientes distintas categorías dentro de nuestros datos, podemos usar facetas. Hay dos funciones para esto,  **facet_grid()** y **facet_wrap()**.  


### facet_grid

`facet_grid(~ variable)` nos devuelve una matriz simétrica de gráficas.  

```{r facet_grid}
 
  # Plot inicial
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
    geom_point(alpha = .2)

  # Un grafico para cada continente
  ## Tip: usamos guides(color = "none") para que no se vea la leyenda asociada a color
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
    geom_point(alpha = .2) +
    facet_grid(~ continent) +
    guides(color = "none")

  # Cambiamos ejes
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
    geom_point(alpha = .2) +
    facet_grid(continent ~ .) +
    guides(color = "none")
  
  # Añadimos una segunda variable
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = country)) +
    geom_line(alpha = .2) +
    facet_grid(continent ~ pop > 5000000) +
    guides(color = "none")

```


### facet_wrap

 `facet_wrap(~ variable)` nos devuelve tantas facetas como niveles de la variable, pudiendo definir el número de filas y columnas que queremos.  

```{r facet_wrap}
  # Plot base
  ggplot(gapminder, aes(lifeExp, fill = continent)) +
    geom_histogram(alpha = .5)

  # Facetas por continente
  ## En 2 columnas
  ggplot(gapminder, aes(lifeExp, fill = continent)) +
    geom_histogram(alpha = .5) +
    facet_wrap( ~ continent, ncol = 2) +
    guides(fill = "none")
```


### gghighlight y facet_wrap

Con la función `gghighlight()` podemos añadir una capa para facilitar la comparación de cada faceta con los datos completos.  

```{r facet_wrap-gghighlight}
  ggplot(gapminder, aes(lifeExp, fill = continent)) +
    geom_histogram(alpha = .5) +
    facet_wrap( ~ continent, nrow = 1) +
    guides(color = "none") +
    gghighlight::gghighlight()

```


### Ejercicios {.ejercicio -}

Usando como base el plot siguiente:  

```
ggplot(mpg, aes(displ, hwy)) + 
  geom_point()
```

- Crea un panel para cada tipo de coche (`class`) en una rejilla simétrica  
- Crea un panel para cada tipo de coche (`class`), mostrando paneles en 3 filas    

<details><summary>Solucion: ![](data/images/hint.png)</summary><span style="color: orange;">`facet_grid()` permite crear rejullas simétricas de panekes, y el parámetro `nrow` de `facet_wrap()` nos ayuda con paneles con números de filas definidos.</span></details>


```{r ejercicio_facetas, echo=FALSE}

ggplot(mpg, aes(displ, hwy)) + 
  geom_point() +
  facet_grid(~ class)
 
ggplot(mpg, aes(displ, hwy)) + 
  geom_point() +
  facet_wrap(~ class, nrow = 3)


```


## Transformaciones estadísticas  

ggplot2 nos permite hacer algunas transformaciones estadísticas al crear los gráficos. Para más detalles, ver [r4ds](https://r4ds.had.co.nz/data-visualisation.html#statistical-transformations).  


### stat_summary 

**Algunas funciones que podemos usar en los gráficos**  

##### {.parameters -}  

- **min()**: mínimo
- **max()**: máximo
- **mean()**: media
- **median()**: mediana
- **sd()**: desviación estandar

##### {-}  

Podemos usar funciones simples de manera directa. En este caso, mostramos un punto con la mediana, y barras que muestran el rango completo de los datos:  

```{r transformaciones-estadisticas-stat_summary-1}

  ggplot(gapminder, aes(continent, lifeExp)) + 
    stat_summary(
      fun.min = min,
      fun.max = max,
      fun = median)
```
  
  
Si queremos usar funciones algo mas complejas, la sintaxis es algo diferente. En este caso mostramos media ± desviación estandar:  

```{r transformaciones-estadisticas-stat_summary-2}

  ggplot(gapminder, aes(continent, lifeExp)) +
    stat_summary(
      fun.min = function(x) mean(x) - sd(x),
      fun.max = function(x) mean(x) + sd(x),
      fun = mean)

```


### Promedios por grupo

Lo interesante es que podemos añadir estas transformaciones estadísticas como una capa más en los gráficos. Así que, a este gráfico inicial...  

```{r transformaciones-estadisticas-promedios-grupo-1}
ggplot(mpg) + 
  geom_jitter(aes(x = class, y = hwy), width = 0.2) +
  theme_minimal()
```

Le podemos añadir el promedio por grupo:  

```{r transformaciones-estadisticas-promedios-grupo-2}
ggplot(mpg) + 
  geom_jitter(aes(x = class, y = hwy), width = 0.2) +
  stat_summary(aes(x = class, y = hwy), fun = mean, color = "red", geom = "point", size = 4, alpha = .7) + 
  theme_minimal()
```


O cosas aún más elaboradas:  

```{r transformaciones-estadisticas-promedios-grupo-02}

ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
  geom_point(alpha = .1) +
  stat_summary(data = gapminder %>% 
                 group_by(continent) %>% 
                 summarise(gdpPercap = mean(gdpPercap),
                           lifeExp  = mean(lifeExp)),
               fun = mean,
               geom = "point",
               size = 4)
    
```




### Ejercicios {.ejercicio -}

Cuando al plot **A** trato de añadirle líneas para cada `class`, me aparece algo como lo de **B**, porque tenemos varios puntos en cada nivel de `displ`.  

```{r ejercicio-7a}
plotA = ggplot(mpg, aes(displ, hwy, color = class)) +
  geom_point() +
  theme(legend.position = "bottom")

plotB = ggplot(mpg, aes(displ, hwy, color = class)) +
  geom_point() +
  geom_line() +
  theme(legend.position = "bottom")

cowplot::plot_grid(plotA, plotB, labels = c("A", "B"))
```

Pero en realidad no quiero que las líneas pasen por todos los puntos, sino que muestren el promedio en cada nivel de `displ` ¿Podrías reproducir el gráfico de abajo?  

```{r ejercicio-7b, echo=FALSE}
  ggplot(mpg, aes(displ, hwy, color = class)) +
    geom_point() +
    stat_summary(fun = mean, geom = "line") +
    theme(legend.position = "bottom")
```

Usando como base:

```
ggplot(gapminder, aes(country, lifeExp, color = continent)) +
  stat_summary(...) +
  facet_grid(...) +
  theme(axis.text.x = element_blank()) # Eliminamos etiquetas de nombres de paises

```
Podrías crear este gráfico? Mostramos mediana ± sd para cada país, organizado por continente.

```{r ejercicio-8, echo=FALSE}

  ggplot(gapminder, aes(country, lifeExp, color = continent)) + 
    stat_summary(
      fun.min = function(x) median(x) - sd(x),
      fun.max = function(x) median(x) + sd(x),
      fun = mean) +
  facet_grid(~ continent) +
  theme(axis.text.x = element_blank())

```
<BR>

## Personalización de gráficas

Habitualmente, un vez hemos creado la gráfica, querremos personalizar varias cosas, como las escalas, colores, estilos, título,  etc.  


### Coordenadas


```{r personalizacion-graficas-coord}

  # Gráfico inicial
  ggplot(gapminder, aes(continent)) +
      geom_bar()

  # coord_flip()
  ggplot(gapminder, aes(continent)) +
    geom_bar() +
    coord_flip()

  # coord_polar()
  ggplot(gapminder, aes(continent)) +
    geom_bar() +
    coord_polar()

```



### Scales  

Usaremos las funciones que empiezan por `scale_` para multitud de cosas, por ejemplo, cambiar las etiquetas de los ejes x o y:  


```{r personalizacion-graficas-axis}
  
  # Grafico inicial
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
    geom_point(alpha = .1) 
  
  # Añadimos breaks en eje y
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
    geom_point(alpha = .1) +
    scale_y_continuous(breaks = seq(0, 100, 5))
  
  # Definimos cuantos breaks queremos
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
    geom_point(alpha = .1) +
    scale_x_continuous(n.breaks = 20, guide = guide_axis(angle = 90)) +
    scale_y_continuous(n.breaks = 20)
  
  # Separador de miles y breaks en x
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
    geom_point(alpha = .1) +
    scale_y_continuous(breaks = seq(0, 100, 5)) +
    scale_x_continuous(labels = scales::comma, n.breaks = 10)
  
  # Formato de $ ($M)
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
    geom_point(alpha = .1) +
    scale_y_continuous(breaks = seq(0, 100, 5)) +
    scale_x_continuous(labels = scales::dollar_format(prefix = "$", suffix = "M"),
                       breaks = seq(0, 100000, 20000))
  
  # Escala log
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
    geom_point(alpha = .1) +
    scale_y_continuous(breaks = seq(0, 100, 5)) +
    scale_x_log10(labels = scales::dollar_format(prefix = "$", suffix = "M"))
  
  # Invertimos escala
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
    geom_point(alpha = .1) +
    scale_y_reverse()

  # No mostramos el texto de los breaks de x
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
    geom_point(alpha = .1) +
    scale_y_reverse() +
    theme(axis.text.x = element_blank())

  # Porcentaje
  ggplot(gapminder, aes(continent, ..prop.., group = 1)) + 
  geom_bar() +
  scale_y_continuous(labels = scales::percent)
  



```

Usar eje secundario (derecho) para mostrar etiquetas:  

```{r advanced-scales}

gapminder_last = gapminder %>% 
  group_by(continent) %>% 
  filter(year == max(year)) %>% 
  summarize(lifeExp = mean(lifeExp))

ggplot(gapminder, aes(year, lifeExp, linetype = continent, color = continent)) + 
  stat_summary(fun = mean, geom = "line") +
  scale_y_continuous(
    limits = c(0, max(gapminder$lifeExp)),
    expand = c(0,0),
    sec.axis = dup_axis(
      breaks = gapminder_last$lifeExp,
      labels = gapminder_last$continent,
      name = NULL)) +
  scale_x_continuous(expand = c(0,0)) +
  guides(color = "none",
         linetype = "none")

```


Usar {geomtextpath} para ubicar las etiquetas en el camino de las líneas:  

```{r geomtextpath}

# https://allancameron.github.io/geomtextpath/

ggplot(gapminder, aes(year, lifeExp, linetype = continent, color = continent)) + 
  
  geomtextpath::geom_labelsmooth(aes(label = continent), text_smoothing = 30, 
                   method = "loess", formula = y ~ x,
                   size = 3, linewidth = 1, boxlinewidth = 0.3) +

  scale_x_continuous(expand = c(0,0)) +
  guides(color = "none",
         linetype = "none")

```


### Ejercicio {.ejercicio -}

El plot del panel (A) tiene varios problemas:  

- los años no son enteros o factores
- los casos no se muestran con un separador de miles  
- la leyenda esta a la derecha ocupado un espacio precioso, ...  

Usando el plot base (A):  

```
ggplot(table1, aes(year, cases)) + 
  geom_line(aes(group = country), colour = "grey50") + 
  geom_point(aes(colour = country))
```

Trata de resolver los problemas e intenta llegar al resultado que se ve en el panel (B). 

<details><summary>Soluciones: ![](data/images/hint.png)</summary><span style="color: orange;">- `as.factor(VARIABLE)`: convierte una variable en categórica  <BR>- `scale_x_discrete(expand = c(.05, 0))` nos ayuda a posicionar los niveles de `year` cerca de los extremos de la gráfica.  </span></details>

```{r geoms-ejercicios-03, echo=FALSE, fig.height=10, fig.width=8}

plot1 = ggplot(table1, aes(year, cases)) + 
  geom_line(aes(group = country), colour = "grey50") + 
  geom_point(aes(colour = country))

plot2 =
  ggplot(table1, aes(as.factor(year), cases)) + 
  geom_line(aes(group = country), colour = "grey50") + 
  geom_point(aes(colour = country), size = 2) +
  scale_y_continuous(labels = scales::comma) +
  scale_x_discrete(expand = c(.05, 0)) +
  labs(title = "Casos de Tuberculosis por año",
       x = "year",
       caption = "SOURCE: http://www.who.int/tb/country/data/download/en/") +
  theme(legend.position = "bottom", 
        legend.title = element_blank())

cowplot::plot_grid(plot1, plot2, 
                   nrow = 2,
                   labels = c("A", "B"))

```

Si te sobra tiempo, puedes tratar de reproducir la siguiente versión mejorada...  

```{r geoms-ejercicios-extra,, echo=FALSE, fig.height=5, fig.width=8}

table1_end = table1 %>% filter(year == max(.$year))

  ggplot(table1, aes(as.factor(year), cases)) + 
  geom_line(aes(group = country), colour = "grey50") + 
  geom_point(aes(colour = country), size = 2) +
  scale_y_continuous(limits = c(0, max(table1_end$cases)),
                     labels = scales::comma,
                     expand = c(0.1,0),
                     sec.axis = dup_axis(
                       breaks = table1_end$cases,
                       labels = table1_end$country,
                       name = NULL)) +
  scale_x_discrete(expand = c(.01,0)) +
  labs(title = "Casos de Tuberculosis por año",
       x = "year",
       caption = "SOURCE: http://www.who.int/tb/country/data/download/en/") +
  theme(legend.position = "bottom", 
        legend.title = element_blank()) +
    guides(color = "none") +
    theme_minimal()
  
```


### Colors and fill scales

Las funciones `scale_color_`, `scale_fill_` nos sirven para hacer cambios globales en los colores o rellenos de las gráficas. Algunos ejemplos:  

```{r personalizacion-graficas-color-fill}

  # Plot inicial
  ggplot(gapminder, aes(continent, lifeExp, fill = continent)) + 
    geom_violin(alpha = .2)

  # Relleno usando paleta blues
  ggplot(gapminder, aes(continent, lifeExp, fill = continent)) + 
    geom_violin(alpha = .2) +
    scale_fill_brewer(palette = "Blues")
  
  # Color grey
  ggplot(iris, aes(Petal.Width, Petal.Length, color = Species)) +
    geom_point() + 
    scale_color_grey(start = 0.2, end = 0.8, na.value = "red")
  
  # Gradient
  ggplot(iris, aes(Petal.Width, Petal.Length, color = Petal.Width)) +
    geom_point() + 
    scale_color_gradient(low = "red", high = "blue")
  
  # Gradient con un numero predefinidos de una paleta
  ggplot(iris, aes(Petal.Width, Petal.Length, color = Petal.Width)) +
    geom_point() + 
    scale_colour_gradientn(colours = terrain.colors(3))
  
```



### Ejercicio {.ejercicio -}

1) Usando como base este plot, podrias cambiarle la paleta de color para usar una de las cualitativas?  

<details><summary>Soluciones: ![](data/images/hint.png)</summary><span style="color: orange;">Ver sección Palettes de la ayuda de `scale_fill_brewer()` </span></details>  


```{r color-01aa, echo=TRUE}

  ggplot(gapminder, aes(continent, lifeExp, fill = continent)) + 
    geom_violin(alpha = .2) +
    scale_fill_brewer(palette = "Blues")

```


2) Si intentamos asignar colores manualmente a los continentes de este modo, recibimos un error:  

```
  ggplot(gapminder, aes(gdpPercap, lifeExp)) + 
    geom_point(color = c("red", "grey", "green", "purple", "black")) 
  # Error: Aesthetics must be either length 1 or the same as the data (1704): colour
```

Podrías resolver el error y mostrar el gráfico de abajo?  

<details><summary>Soluciones: ![](data/images/hint.png)</summary><span style="color: orange;">Tenemos que:  
- indicar que el color depende de `continent`  
- usar `scale_color_manual()`, con el parámetro `values` para asignar los colores (ver ejemplos en la ayuda de la función)</span></details>



```{r color-01b, echo=FALSE}
  ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) + 
    geom_point() +
    scale_color_manual(values = c("red", "grey", "green", "purple", "black"))
```
 


### Combinando gráficas {#combinando-graficas}

Con {[cowplot](https://cran.r-project.org/web/packages/cowplot/vignettes/introduction.html#:~:text=The%20cowplot%20package%20is%20a,or%20mix%20plots%20with%20images.)} podemos combinar gráficas de manera muy simple. Otro paquete muy interesante es {[patchwork](https://patchwork.data-imaginist.com/)}.  

```{r personalizando-combinando-basico}

plot1 = ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
  geom_point(alpha = .1) +
  scale_y_continuous(breaks = seq(0, 100, 5)) +
  scale_x_log10(labels = scales::dollar_format(prefix = "$", suffix = "M")) +
  theme(legend.position = "top")

plot2 = ggplot(gapminder, aes(continent, ..prop.., group = 1)) + 
  geom_bar() +
  scale_y_continuous(labels = scales::percent) +
  coord_flip()
  
cowplot::plot_grid(plot2, plot1, rel_widths = c(.3, 0.7))

```




##### Ejercicio {.ejercicio -}

1) Combina los dos plots del ejercicio anterior, con las siguientes modificaciones: 

- Elimina las leyendas asociadas a colores y rellenos
- Usa la paleta "Accent" para los colores y rellenos

<details><summary>Soluciones: ![](data/images/hint.png)</summary><span style="color: orange;">- guides(fill = "none") quita la leyenda asociada a `fill`...  <BR>- scale_fill_brewer(palette = "Accent") asigna la paleta "Accent" a los rellenos (`fill`)</span></details>  


```{r ejercicio-combinar-plots, echo=FALSE}

 plot1 = ggplot(gapminder, aes(continent, lifeExp, fill = continent)) + 
    geom_violin(alpha = .2) +
    scale_fill_brewer(palette = "Accent") +
    guides(fill = "none")

  plot2 = ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) + 
    geom_point() +
    scale_color_brewer(palette = "Accent") +
    guides(color = "none")


cowplot::plot_grid(plot1, plot2, rel_widths = c(.3, 0.7))

```

---  

#### Combinando múltiples gráficas

Podemos combinar múltiples gráficas y llegar a hacer cosas mucho más complejas como combinar un [scatteplot con un par de histogramas](https://stackoverflow.com/questions/8545035/scatterplot-with-marginal-histograms-in-ggplot2/56440634#56440634):  

```{r personalizando-combinando-avanzado}

# Set up scatterplot
scatterplot <- ggplot(iris, aes(Sepal.Length, Sepal.Width, color = Species)) +
  geom_point(size = 3, alpha = 0.6) +
  guides(color = "none") +
  theme(plot.margin = margin())


# Define marginal histogram
marginal_distribution <- function(x, var, group) {
  ggplot(x, aes_string(x = var, fill = group)) +
    geom_histogram(bins = 30, alpha = 0.4, position = "identity") +
    # geom_density(alpha = 0.4, size = 0.1) +
    guides(fill = "none") +
    theme_void() +
    theme(plot.margin = margin())
}

# Set up marginal histograms
x_hist <- marginal_distribution(iris, "Sepal.Length", "Species")
y_hist <- marginal_distribution(iris, "Sepal.Width", "Species") +
  coord_flip()

# Align histograms with scatterplot
aligned_x_hist <- align_plots(x_hist, scatterplot, align = "v")[[1]]
aligned_y_hist <- align_plots(y_hist, scatterplot, align = "h")[[1]]


# Arrange plots
cowplot::plot_grid(
  aligned_x_hist, NULL, scatterplot, aligned_y_hist,
  ncol = 2, nrow = 2, 
  rel_heights = c(0.2, 1), rel_widths = c(1, 0.2)
  )

```


### Estilos

Los estilos nos permiten personalizar los gráficos de manera muy sencilla, por ejemplo, usando {[ggtheme](https://ggplot2.tidyverse.org/reference/ggtheme.html)}. Podéis ver un tutorial [aquí](https://michaeltoth.me/you-need-to-start-branding-your-graphs-heres-how-with-ggplot.html).  

Primero creamos un gráfico sobre el que aplicaremos estilos.  

```{r personalizacion-graficas-01}

p <- ggplot(iris, aes(Petal.Width, Petal.Length, color = Species)) +
  geom_point() +
  labs(title = 'A ggplot simple graph',
       subtitle = 'Simple tweaks to improve plots, or not',
       x = '',
       y = '',
       caption = 'https://github.com/gorkang / @gorkang') +
    theme_gray() # This is the default. Needed here because of the Bookdown theme

p

```

Usando el tema fivethirtyeight:  

```{r personalizacion-graficas-02}

p +
  ggthemes::scale_color_fivethirtyeight() +
  ggthemes::theme_fivethirtyeight()

```

Usando el tema economist:  

```{r personalizacion-graficas-03}

p +
  ggthemes::scale_color_economist() +
  ggthemes::theme_economist()

```


### Ejercicios {.ejercicio -}

Serías capaz de reproducir este gráfico, usando el dataframe `diamonds` y el `theme_economist`?  

Gráfica inicial:  

```
ggplot(diamonds, aes(price, cut, fill = cut, color = cut)) +
  ggridges::geom_density_ridges(alpha = .6)
```

<details><summary>Soluciones: ![](data/images/hint.png)</summary><span style="color: orange;">- scale_x_log10() nos permite transformar el eje x a una escala logarítmica  <BR>- Hay que aplicar un `ggthemes::scale_*` para cada elemento: `color`, `fill`... </span></details>  


```{r ejercicio-6a, echo=FALSE}

ggplot(diamonds, aes(price, cut, fill = cut, color = cut)) +
  ggridges::geom_density_ridges(alpha = .6) +
  scale_x_log10() +
  labs(title = "Distribución de precios (log) en función del tipo de corte",
       caption = "@gorkang",
       x = "price (log)") +
  ggthemes::scale_fill_economist() +
  ggthemes::scale_color_economist() +
  ggthemes::theme_economist() +
  theme(legend.position = "none", 
        text = element_text(size = 14))

```

---  

Serías capaz de reproducir este gráfico, usando el dataframe `gapminder` y la paleta `Accent`? 


Gráfica inicial:  

```
ggplot(gapminder, aes(gdpPercap, continent, fill = continent, color = continent)) +
  ggridges::geom_density_ridges(alpha = .6)
```

<details><summary>Soluciones: ![](data/images/hint.png)</summary><span style="color: orange;">- `scales::dollar_format()` aplicado al parámetro `labels` de las funciones `scale_x_*` nos permite darle formato de moneda a las etiquetas de la escala x</span></details>  


```{r ejercicio-6b, echo=FALSE}

ggplot(gapminder, aes(gdpPercap, continent, fill = continent, color = continent)) +
  ggridges::geom_density_ridges(alpha = .6) +
  scale_color_brewer(palette = "Accent") +
  scale_fill_brewer(palette = "Accent") +
  theme(legend.position = "none", 
        text = element_text(size = 14),
        axis.title.y = element_blank()) +
  labs(x = "GDP") +
  scale_x_log10(labels = scales::dollar_format(prefix = "$", suffix = "M"))

```




## Visualización interactiva

El paquete {[plotly](https://plotly.com/r/)} nos permite crear gráficas con algunos niveles de interactividad usando funciones propias, o modificando gráficas creadas con ggplot.  


### ggplots interactivos con plotly

Scatterplot creado con ggplot donde se puede ver el valor de los puntos, seleccionar áreas, etc.

```{r graficas-interactivas, fig.height=8, fig.width=8}

plotly::ggplotly(
  ggplot(gapminder %>% filter(year == 2007), aes(gdpPercap, lifeExp, color = continent, size = country)) +
    geom_point(alpha = .3, point = 2) +
    scale_y_continuous(breaks = seq(0, 100, 5)) +
    scale_x_log10(labels = scales::dollar_format(prefix = "$", suffix = "M")) +
  theme(legend.position = "none")
  )

```


### Surface plots con plotly

Surface plot creado con plotly donde se muestra la relación entre 3 variables en un entorno interactivo 3D.  

```{r graficas-interactivas2, fig.height=8, fig.width=8}

DF_RAW = structure(c(181, 163, 60, 124, 76, 62, 73, 59, 17, 21, 26, 7, 1, 2, 3, 
                     188, 145, 61, 130, 61, 59, 62, 57, 20, 22, 22, 6, 4, 5, 5, 
                     137, 154, 54, 191, 75, 56, 65, 56, 22, 27, 33, 14, 5, 5, 5, 
                     126, 185, 65, 109, 51, 71, 57, 38, 25, 23, 21, 10, 5, 5, 5, 
                     150, 144, 44, 123, 58, 24, 48, 41, 19, 26, 21, 5, 5, 5, 5, 
                     138, 137, 61, 130, 67, 34, 60, 44, 19, 21, 16, 4, 5, 5, 5, 
                     121, 146, 101, 92, 70, 74, 88, 33, 18, 39, 24, 12, 5, 5, 5, 
                     100, 160, 129, 117, 70, 61, 42, 35, 22, 25, 21, 7, 10, 23, 8, 
                     100, 129, 130, 107, 64, 61, 44, 25, 23, 30, 18, 11, 20, 58, 40, 
                     100, 136, 131, 96, 53, 31, 51, 37, 43, 31, 19, 2, 22, 40, 41, 
                     100, 124, 154, 74, 62, 44, 34, 15, 26, 23, 20, 6, 23, 10, 19, 
                     100, 126, 251, 76, 73, 84, 47, 40, 32, 25, 32, 6, 13, 10, 13, 
                     100, 129, 194, 91, 53, 99, 46, 34, 60, 21, 17, 6, 14, 14, 26, 
                     100, 115, 119, 88, 64, 108, 37, 24, 49, 26, 17, 6, 15, 15, 47), 
                   .Dim = 15:14, 
                   .Dimnames = list(c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15"), 
                                    c("2006", "2007", "2008", "2009", "2010", "2011", "2012", "2013", "2014", "2015", "2016", "2017", "2018", "2019")))

DF = DF_RAW
plot1 = plotly::plot_ly(x = ~ colnames(DF),
                y = ~ rownames(DF),
                z = ~ DF) %>% 
  plotly::add_surface(name = "3D mesh",
                      connectgaps = TRUE, hidesurface = TRUE,
                      contours = list(
                        x = list(show = TRUE, width = 1,  highlightwidth = 2, highlightcolor = "#41a7b3", highlight = TRUE),
                        y = list(show = TRUE, width = 1,  highlightwidth = 2, highlightcolor = "#41a7b3", highlight = TRUE),
                        z = list(show = FALSE, width = 1,  highlightwidth = 2, highlightcolor = "#41a7b3", highlight = FALSE)
                      )) %>% 
  plotly::add_surface(name = "surface",
                      connectgaps = FALSE,
                      contours = list(
                        x = list(show = F, width = 1,  highlightwidth = 2, highlightcolor = "#41a7b3", highlight = TRUE),
                        y = list(show = F, width = 1,  highlightwidth = 2, highlightcolor = "#41a7b3", highlight = TRUE),
                        z = list(show = FALSE, width = 1,  highlightwidth = 2, highlightcolor = "#41a7b3", highlight = FALSE)
                      )
   )

plot1
```


### Animando gráficas con gganimate

{[gganimate](https://gganimate.com/)} nos permite crear ggplots añadiendo la dimensión temporal  

```{r animando-graficas, fig.height=4, fig.width=8, eval=FALSE}

if (!require('gganimate')) remotes::install_github('thomasp85/gganimate'); library('gganimate')
#sudo apt-get install ffmpeg
  
p = ggplot(gapminder, aes(gdpPercap, lifeExp, size = pop, colour = country)) +
  geom_point(alpha = 0.7, show.legend = FALSE) +
  scale_colour_manual(values = country_colors) +
  scale_size(range = c(2, 12)) +
  scale_x_log10() +
  facet_wrap(~continent) +
  
  # Here comes the gganimate specific bits
  labs(title = 'Year: {frame_time}', x = 'GDP per capita', y = 'life expectancy') +
  transition_time(year) +
  ease_aes('linear')

  # Create animated plot
  animate(p, renderer = ffmpeg_renderer(), height = 6, width = 10, units = "in", res = 300)
  
  # Save plot
    # anim_save("name_file.mp4", animation = last_animation())

```

![](data/images/gganimate.mp4){width="100%"}




## Bibliografía {.bibliografia -}

+ Matejka, J., & Fitzmaurice, G. (2017, May). Same stats, different graphs: Generating datasets with varied appearance and identical statistics through simulated annealing. In Proceedings of the 2017 CHI Conference on Human Factors in Computing Systems (pp. 1290-1294). ACM.

+ https://bbc.github.io/rcookbook/  

+ https://github.com/bbc/bbplot  

+ https://github.com/dreamRs/esquisse  

+ Garrick Aden-Buie. A Gentle Guide to the Grammar of Graphics with ggplot2: https://github.com/gadenbuie/gentle-ggplot2

+ Michael Toth. You Need to Start Branding Your Graphs. Here's How, with ggplot!: https://michaeltoth.me/you-need-to-start-branding-your-graphs-heres-how-with-ggplot.html  

+ Claus Wilke: https://wilkelab.org/practicalgg/  

+ Thomas Lin Pedersen: 
  
    + Part 1: https://www.youtube.com/watch?v=h29g21z0a68
    + Part 2: https://www.youtube.com/watch?v=0m4yywqNPVY

+ Big Book or R : https://www.bigbookofr.com/index.html
